{
  "swagger": "2.0",
  "info": {
    "description": "Workbench notebooks service.\n",
    "license": {
      "name": "BSD",
      "url": "http://opensource.org/licenses/BSD-3-Clause"
    },
    "termsOfService": "https://github.com/broadinstitute/leonardo",
    "title": "Leonardo",
    "version": "0.1.0"
  },
  "paths": {
    "/api/cluster/v2/{googleProject}/{clusterName}": {
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName. only lowercase alphanumeric characters, numbers and dashes are allowed in cluster name",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          },
          {
            "description": "Request for new cluster",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Cluster creation request accepted",
            "schema": {
              "$ref": "#/definitions/Cluster"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "* The request is completed without waiting for the initiation of the cluster's creation on the Google side.\n  This reduces the response time compared with the other version.\n* Default labels clusterName, googleProject, serviceAccount, and notebookExtension cannot be overridden.\n",
        "operationId": "createClusterV2",
        "summary": "Creates a new Dataproc cluster in the given project with the given name."
      }
    },
    "/api/cluster/{googleProject}/{clusterName}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Cluster deletion request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "deletes a Dataproc cluster",
        "operationId": "deleteCluster",
        "summary": "Deletes an existing Dataproc cluster in the given project"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Cluster found, here are the details",
            "schema": {
              "$ref": "#/definitions/Cluster"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "Returns information about an existing Dataproc cluster managed by Leo. Poll this to find out when your cluster has finished starting up.",
        "operationId": "getCluster",
        "summary": "Get details of a Dataproc cluster"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          },
          {
            "description": "Request for new cluster",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Cluster creation successful",
            "schema": {
              "$ref": "#/definitions/Cluster"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "Default labels clusterName, googleProject, serviceAccount, and notebookExtension cannot be overridden.",
        "operationId": "createCluster",
        "summary": "Creates a new Dataproc cluster in the given project with the given name"
      }
    },
    "/api/cluster/{googleProject}/{clusterName}/start": {
      "post": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Cluster start request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Cluster cannot be started",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "Starts the instances of a stopped Dataproc cluster.\n",
        "operationId": "startCluster",
        "summary": "Starts a Dataproc cluster"
      }
    },
    "/api/cluster/{googleProject}/{clusterName}/stop": {
      "post": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Cluster stop request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Cluster cannot be stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "Stops the instances of a Dataproc cluster, but retains any data persisted on disk. The\ncluster may be restarted with the /start endpoint.\n",
        "operationId": "stopCluster",
        "summary": "Stops a Dataproc cluster"
      }
    },
    "/api/clusters": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2\nreturns all clusters that contain the key1/val1 and key2/val2 labels (possibly among other labels).\nNote: this string format is a workaround because Swagger doesn't support free-form\nquery string parameters. The recommended way to use this endpoint is to specify the\nlabels as top-level query string parameters. For instance: GET /api/clusters?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any clusters with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of clusters",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListClusterResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "List all active clusters, optionally filtering on a set of labels",
        "operationId": "listClusters",
        "summary": "List all active clusters"
      }
    },
    "/api/clusters/{googleProject}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2\nreturns all clusters that contain the key1/val1 and key2/val2 labels (possibly among other labels).\nNote: this string format is a workaround because Swagger doesn't support free-form\nquery string parameters. The recommended way to use this endpoint is to specify the\nlabels as top-level query string parameters. For instance: GET /api/clusters?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any clusters with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of clusters",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListClusterResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "cluster"
        ],
        "deprecated": true,
        "description": "List all active clusters within the given Google project, optionally filtering on a set of labels",
        "operationId": "listClustersByProject",
        "summary": "List all active clusters within the given Google project"
      }
    },
    "/api/google/v1/apps": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all apps that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/app?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any apps with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of apps",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListAppResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "apps"
        ],
        "description": "List kubernetes apps the caller has access to, without specifying a project",
        "operationId": "listApp",
        "summary": "List apps"
      }
    },
    "/api/google/v1/apps/{googleProject}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all apps that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/app?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any apps with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of apps",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListAppResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "apps"
        ],
        "description": "List kubernetes apps the caller has access to with a project filter",
        "operationId": "listAppByProject",
        "summary": "List apps within a project"
      }
    },
    "/api/google/v1/apps/{googleProject}/batchNodepoolCreate": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/BatchNodepoolCreateRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Batch nodepool creation request successful"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "403": {
            "description": "User does not have permission to perform action"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "apps"
        ],
        "description": "This will fail if a cluster already exists in the project",
        "operationId": "batchNodepoolCreate",
        "summary": "Creates a cluster with pool of unclaimed nodepools, such that nodepools already exist at app creation time"
      }
    },
    "/api/google/v1/apps/{googleProject}/{appName}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "appName",
            "in": "path",
            "name": "appName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "App deletion request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on App"
          },
          "404": {
            "description": "App not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "apps"
        ],
        "description": "deletes an App",
        "operationId": "deleteApp",
        "summary": "Deletes an existing app in the given project"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "appName",
            "in": "path",
            "name": "appName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "App found, here are the details",
            "schema": {
              "$ref": "#/definitions/GetAppResponse"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on App"
          },
          "404": {
            "description": "App not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "apps"
        ],
        "description": "Returns information about an existing App managed by Leo. Poll this to find out when your app has finished starting up.\n",
        "operationId": "getApp",
        "summary": "Get details of an app"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "appName",
            "in": "path",
            "name": "appName",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/CreateAppRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "App creation successful"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on App"
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "security": [
          {
            "googleoauth": [
              "openid",
              "email",
              "profile"
            ]
          }
        ],
        "tags": [
          "apps"
        ],
        "description": "Default labels appName, googleProject, serviceAccount, and creator cannot be overridden.",
        "operationId": "createApp",
        "summary": "Creates a new app in the given project with the given name"
      }
    },
    "/api/google/v1/disks": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all persistent disks that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/disks?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any persistent disks with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of persistent disks",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListPersistentDiskResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "List all persistent disks, optionally filtering on a set of labels",
        "operationId": "listDisks",
        "summary": "List all persistent disks that the caller has access to"
      }
    },
    "/api/google/v1/disks/{googleProject}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all persistent disks that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/disks?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any persistent disks with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of persistent disks",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListPersistentDiskResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "List all persistent disks within the given Google project, optionally filtering on a set of labels",
        "operationId": "listDisksByProject",
        "summary": "List all persistent disks within the given Google project that the caller has access to"
      }
    },
    "/api/google/v1/disks/{googleProject}/{name}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "diskName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Persistent disk deletion request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on persistent disk"
          },
          "404": {
            "description": "Persistent disk not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "Deletes a persistent disk",
        "operationId": "deleteDisk",
        "summary": "Deletes an existing persistent disk in the given project"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "diskName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Persistent disk found, here are the details",
            "schema": {
              "$ref": "#/definitions/GetPersistentDiskResponse"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on persistent disk"
          },
          "404": {
            "description": "Persistent disk not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "Returns information about an existing persistent disk managed by Leo. Poll this to find out when your disk has finished starting up.\n",
        "operationId": "getDisk",
        "summary": "Get details of a persistent disk"
      },
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "diskName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/UpdateDiskRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Persistent disk update request accepted"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "In order to update the configuration of a persistent disk, it must first be ready",
        "operationId": "updateDisk",
        "summary": "Updates the configuration of a persistent disk"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "diskName. only lowercase alphanumeric characters, numbers and dashes are allowed",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/CreateDiskRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Persistent disk creation request accepted"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "disks"
        ],
        "description": "The request is completed without waiting for the persistent disk to be created in Google. The disk status can be polled using the getDisk API. Default labels diskName, googleProject, and creator cannot be overridden.\n",
        "operationId": "createDisk",
        "summary": "Creates a new persistent disk in the given project with the given name."
      }
    },
    "/api/google/v1/runtimes": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all runtimes that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/runtimes?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any runtimes with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of runtimes",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListClusterResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "List all runtimes, optionally filtering on a set of labels",
        "operationId": "listRuntimes",
        "summary": "List all runtimes that the caller has access to"
      }
    },
    "/api/google/v1/runtimes/{googleProject}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "Optional label key-value pairs to filter results by. Example: Querying by key1=val1,key2=val2 returns all runtimes that contain the key1/val1 and key2/val2 labels (possibly among other labels). Note: this string format is a workaround because Swagger doesn't support free-form query string parameters. The recommended way to use this endpoint is to specify the labels as top-level query string parameters. For instance: GET /api/google/v1/runtimes?key1=val1&key2=val2.\n",
            "in": "query",
            "name": "_labels",
            "required": false,
            "type": "string"
          },
          {
            "default": false,
            "description": "Optional filter that includes any runtimes with a Deleted status.",
            "in": "query",
            "name": "includeDeleted",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "List of runtimes",
            "schema": {
              "items": {
                "$ref": "#/definitions/ListRuntimeResponse"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "List all runtimes within the given Google project, optionally filtering on a set of labels",
        "operationId": "listRuntimesByProject",
        "summary": "List all runtimes within the given Google project that the caller has access to"
      }
    },
    "/api/google/v1/runtimes/{googleProject}/{name}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtimeName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "default": false,
            "description": "Whether or not disk should be deleted if the runtime is using persistent disk. Default to false if not specified",
            "in": "query",
            "name": "deleteDisk",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "202": {
            "description": "Runtime deletion request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on cluster"
          },
          "404": {
            "description": "Runtime not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "deletes a runtime",
        "operationId": "deleteRuntime",
        "summary": "Deletes an existing Dataproc cluster or Google Compute Engine instance in the given project"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtimeName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Runtime found, here are the details",
            "schema": {
              "$ref": "#/definitions/GetRuntimeResponse"
            }
          },
          "403": {
            "description": "User does not have permission to perform action on runtime"
          },
          "404": {
            "description": "Runtime not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "Returns information about an existing runtime managed by Leo. Poll this to find out when your runtime has finished starting up.\n",
        "operationId": "getRuntime",
        "summary": "Get details of a runtime"
      },
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtimeName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/UpdateRuntimeRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Runtime update request accepted"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "In order to update the configuration of a runtime, it must first be running or paused",
        "operationId": "updateRuntime",
        "summary": "Updates the configuration of a runtime"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtimeName. only lowercase alphanumeric characters, numbers and dashes are allowed",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/CreateRuntimeRequest"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Runtime creation request accepted"
          },
          "400": {
            "description": "Bad Request",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "The request is completed without waiting for the runtime to be created in Google. The runtime status can be polled using the getRuntime API. Default labels runtimeName, googleProject, serviceAccount, and notebookExtension cannot be overridden.\n",
        "operationId": "createRuntime",
        "summary": "Creates a new Dataproc cluster or Google Compute Engine instance in the given project with the given name."
      }
    },
    "/api/google/v1/runtimes/{googleProject}/{name}/start": {
      "post": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtimeName",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Runtime start request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on runtime"
          },
          "404": {
            "description": "Runtime not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Runtime cannot be started",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "Starts the a stopped runtime",
        "operationId": "startRuntime",
        "summary": "Starts a Dataproc cluster or Google Compute Engine instance"
      }
    },
    "/api/google/v1/runtimes/{googleProject}/{name}/stop": {
      "post": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "runtime name",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "Runtime stop request accepted"
          },
          "403": {
            "description": "User does not have permission to perform action on runtime"
          },
          "404": {
            "description": "Runtime not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "409": {
            "description": "Runtime cannot be stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "runtimes"
        ],
        "description": "Stops the running compute, but retains any data persisted on disk. The runtime may be restarted with the /start endpoint.\n",
        "operationId": "stopRuntime",
        "summary": "Stops a Dataproc cluster or Google Compute Engine instance"
      }
    },
    "/notebooks/invalidateToken": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Successfully invalidated a token"
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "notebooks"
        ],
        "deprecated": true,
        "description": "If using Google token-based auth, call this endpoint when a user's Google token is invalidated\n(e.g. when logging out of the application). This ensures that the token is also invalidated in Leo\nand that the user's proxied notebook connections stop working.\n",
        "operationId": "invalidateTokenApi",
        "summary": "(Deprecated) Invalidates a token"
      }
    },
    "/notebooks/{googleProject}/{clusterName}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "Cluster is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "423": {
            "description": "Cluster not ready for requests. It could be starting.",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "notebooks"
        ],
        "deprecated": true,
        "description": "This URI supports all HTTP methods, not just GET as implied by this Swagger.\nProxies all requests through to the Jupyter notebook server running on the given cluster.\n",
        "operationId": "proxyCluster",
        "summary": "(Deprecated) Access Jupyter notebooks on a Dataproc cluster"
      }
    },
    "/notebooks/{googleProject}/{clusterName}/api/localize": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          },
          {
            "default": false,
            "description": "If true, the copy will happen asynchronously to the request and the API will always return 200.\nIf false (the default), the copy will happen synchronously and the response will reflect any errors encountered during the copy.\n",
            "in": "query",
            "name": "async",
            "required": false,
            "type": "boolean"
          },
          {
            "description": "JSON object. Keys represent destinations, values represent sources. The following rules apply:\n* If either the source or destination is a GCS path, it will be sent to [gsutil cp](https://cloud.google.com/storage/docs/gsutil/commands/cp). Therefore\n  this can be used to localize a file _from_ a bucket _to_ the notebook server; or delocalize a file _from_ the notebook server _to_ a bucket.\n* If the source is a Data URI, then the destination file will be created with the decoded data URI contents. This mode can only be used to localize\n  files to the notebook server.\nIn both cases all paths will be quoted & sanitized, and intermediate local directories will be made.\nNote that duplicate keys will lead to unexpected behaviour, so specify the destination filename explicitly if you want to localize multiple files to the same directory.\n",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "description": "",
              "example": {
                "gs://upload/to/this/bucketdir": "~/file.txt",
                "~/data.txt": "data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D",
                "~/directory": "gs://somebucket/*",
                "~/file.txt": "gs://somebucket/file.txt"
              },
              "type": "object"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "400": {
            "description": "Bad request. Your POST body is probably malformed: it should be a string/string JSON object."
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "420": {
            "description": "Cluster not ready",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "Cluster is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "notebooks"
        ],
        "deprecated": true,
        "description": "Sends a command to a Jupyter notebook server to localize files to/from the server. Supports GCS paths and [Data URIs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs).\nOutput, including any errors, will appear in `localization.log` in the working directory of the Jupyter notebook server.\nBy default this operation will happen synchronously and the response status will reflect any errors encountered in the copy.\nHowever, if the `async` parameter is specfied then the localization will happen asynchronously to the request, and the API will always return 200.\n",
        "operationId": "proxyLocalize",
        "summary": "Localize files to/from a Jupyter notebook server"
      }
    },
    "/notebooks/{googleProject}/{clusterName}/setCookie": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully set a cookie"
          },
          "401": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "notebooks"
        ],
        "deprecated": true,
        "description": "If using Google token-based authorization to a Jupyter notebook, the Leo proxy accepts a\nGoogle token passed as a cookie value. This endpoint facilitates setting that cookie.\nIt accepts a bearer token in an Authorization header and responds with a Set-Cookie header.\n",
        "operationId": "setCookieApi",
        "summary": "(Deprecated) Sets a browser cookie needed to authorize connections to a Jupyter notebook"
      }
    },
    "/proxy/google/v1/apps/{googleProject}/{appName}/{serviceName}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "appName",
            "in": "path",
            "name": "appName",
            "required": true,
            "type": "string"
          },
          {
            "description": "serviceName",
            "in": "path",
            "name": "serviceName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "App or service not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "420": {
            "description": "App not ready",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "App is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "This URI supports all HTTP methods, not just GET as implied by this Swagger.\nProxies all requests through to the app via an ingress controller\n",
        "operationId": "proxyApp",
        "summary": "Access an app if the app and service name exists"
      }
    },
    "/proxy/invalidateToken": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Successfully invalidated a token"
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "If using Google token-based auth, call this endpoint when a user's Google token is invalidated\n(e.g. when logging out of the application). This ensures that the token is also invalidated in Leo\nand that the user's proxied connections stop working.\n",
        "operationId": "invalidateToken",
        "summary": "Invalidates a token"
      }
    },
    "/proxy/{googleProject}/{clusterName}/jupyter": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "420": {
            "description": "Cluster not ready",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "Cluster is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "This URI supports all HTTP methods, not just GET as implied by this Swagger.\nProxies all requests through to the tool server running on the given cluster.\n",
        "operationId": "proxyClusterJupyter",
        "summary": "Access Jupyter (if installed) on a Dataproc cluster"
      }
    },
    "/proxy/{googleProject}/{clusterName}/jupyter/lab": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "420": {
            "description": "Cluster not ready",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "Cluster is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "This URI supports all HTTP methods, not just GET as implied by this Swagger.\nProxies all requests through to the tool server running on the given cluster.\n",
        "operationId": "proxyClusterJupyterLab",
        "summary": "Access Jupyter Lab (if installed) on a Dataproc cluster"
      }
    },
    "/proxy/{googleProject}/{clusterName}/rstudio": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "googleProject",
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Proxy connection successful"
          },
          "403": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "420": {
            "description": "Cluster not ready",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "422": {
            "description": "Cluster is stopped",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "This URI supports all HTTP methods, not just GET as implied by this Swagger.\nProxies all requests through to the tool server running on the given cluster.\n",
        "operationId": "proxyClusterRStudio",
        "summary": "Access RStudio (if installed) on a Dataproc cluster"
      }
    },
    "/proxy/{googleProject}/{clusterName}/setCookie": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "googleProject",
            "required": true,
            "type": "string"
          },
          {
            "description": "clusterName",
            "in": "path",
            "name": "clusterName",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully set a cookie"
          },
          "401": {
            "description": "Proxy connection unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "404": {
            "description": "Cluster not found",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          },
          "500": {
            "description": "Internal Error",
            "schema": {
              "$ref": "#/definitions/ErrorReport"
            }
          }
        },
        "tags": [
          "proxy"
        ],
        "description": "If using Google token-based authorization to a cluster, the Leo proxy accepts a\nGoogle token passed as a cookie value. This endpoint facilitates setting that cookie.\nIt accepts a bearer token in an Authorization header and responds with a Set-Cookie header.\n",
        "operationId": "setCookie",
        "summary": "Sets a browser cookie needed to authorize connections to a Dataproc cluster"
      }
    },
    "/status": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "System ok",
            "schema": {
              "$ref": "#/definitions/SystemStatus"
            }
          },
          "500": {
            "description": "One or more subsystems down",
            "schema": {
              "$ref": "#/definitions/SystemStatus"
            }
          }
        },
        "security": [],
        "tags": [
          "service_info"
        ],
        "operationId": "getSystemStatus",
        "summary": "Gets system status"
      }
    },
    "/version": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/LeonardoVersion"
            }
          }
        },
        "security": [],
        "tags": [
          "service_info"
        ],
        "operationId": "leonardoVersion",
        "summary": "Returns the currently deployed version of this service."
      }
    }
  },
  "definitions": {
    "AppStatus": {
      "enum": [
        "STATUS_UNSPECIFIED",
        "RUNNING",
        "ERROR",
        "DELETING",
        "DELETED",
        "PROVISIONING"
      ],
      "type": "string"
    },
    "AsyncRuntimeFields": {
      "description": "Fields populated asynchronously to the runtime's creation",
      "properties": {
        "googleId": {
          "description": "Google's UUID for the runtime",
          "type": "string"
        },
        "hostIp": {
          "description": "optional. The hostIP associated with this runtime.",
          "type": "string"
        },
        "operationName": {
          "description": "The google operation name for creating this runtime. This is globally unique among operation names in google.",
          "type": "string"
        },
        "stagingBucket": {
          "description": "The staging bucket associated with this user's runtime. Used for various logs associated with runtime creation. Useful if creation fails.",
          "type": "string"
        }
      },
      "required": [
        "googleId",
        "operationName",
        "stagingBucket"
      ],
      "type": "object"
    },
    "AuditInfo": {
      "description": "Fields associated with the audit trail for this runtime",
      "properties": {
        "createdDate": {
          "description": "timestamp for the date this runtime was created in ISO 8601 format",
          "type": "string"
        },
        "creator": {
          "description": "The email for the user that created this runtime",
          "type": "string"
        },
        "dateAccessed": {
          "description": "timestamp for the date this runtime was last accessed in ISO 8601 format. This is null if it has not been deleted yet.",
          "type": "string"
        },
        "destroyedDate": {
          "description": "timestamp for the date this runtime was deleted in ISO 8601 format. This is null if it has not been deleted yet.",
          "type": "string"
        },
        "kernelFoundBusyDate": {
          "description": "timestamp for the date the kernel for the tool (i.e. Jupyter) in this runtime was last found busy, aka in use, in ISO 8601 format.",
          "type": "string"
        }
      },
      "required": [
        "creator",
        "createdDate",
        "dateAccessed"
      ],
      "type": "object"
    },
    "BatchNodepoolCreateRequest": {
      "description": "The configuration for a pool of nodepools, used to create a cluster with pre-created nodepools",
      "properties": {
        "kubernetesRuntimeConfig": {
          "$ref": "#/definitions/KubernetesRuntimeConfig"
        },
        "numNodepools": {
          "description": "number of nodepools to pre-create in the cluster. We enforce a max of 200. There will be an additional default nodepool created as well.",
          "type": "integer"
        }
      },
      "required": [
        "numNodepools"
      ],
      "type": "object"
    },
    "Cluster": {
      "description": "",
      "properties": {
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the cluster is autopaused. A value of 0 is equivalent to autopause being turned off.",
          "type": "integer"
        },
        "clusterName": {
          "description": "The user-supplied name for the cluster",
          "type": "string"
        },
        "createdDate": {
          "description": "The date and time the cluster was created, in ISO-8601 format",
          "type": "string"
        },
        "customClusterEnvironmentVariables": {
          "description": "Optional environment variables to be set on the cluster.",
          "type": "object"
        },
        "dateAccessed": {
          "description": "The date and time the cluster was last accessed, in ISO-8601 format.\nDate accessed is defined as the last time the cluster was created, modified, or accessed via the proxy.\n",
          "type": "string"
        },
        "defaultClientId": {
          "description": "The default Google Client ID.",
          "type": "string"
        },
        "destroyedDate": {
          "description": "The date and time the cluster was destroyed, in ISO-8601 format",
          "type": "string"
        },
        "errors": {
          "description": "The list of errors that were encountered on cluster create. Each error consists of the error message, code and timestamp",
          "items": {
            "$ref": "#/definitions/ClusterError"
          },
          "type": "array"
        },
        "googleId": {
          "description": "Google's UUID for the cluster",
          "type": "string"
        },
        "googleProject": {
          "description": "The Google Project used to create the cluster",
          "type": "string"
        },
        "googleServiceAccount": {
          "description": "The Google Service Account used to create the cluster",
          "type": "string"
        },
        "hostIp": {
          "description": "The IP address of the cluster master node",
          "type": "string"
        },
        "id": {
          "description": "The internally-referenced ID of the cluster",
          "type": "string"
        },
        "instances": {
          "description": "Array of instances belonging to this cluster",
          "items": {
            "$ref": "#/definitions/Instance"
          },
          "type": "array"
        },
        "internalId": {
          "description": "Internal resource ID of the cluster",
          "type": "string"
        },
        "labels": {
          "description": "The labels to be placed on the cluster. Of type Map[String,String]",
          "type": "object"
        },
        "machineConfig": {
          "$ref": "#/definitions/MachineConfig"
        },
        "operationName": {
          "description": "Google's operation ID for the cluster",
          "type": "string"
        },
        "scopes": {
          "description": "The scopes for the cluster.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "status": {
          "$ref": "#/definitions/ClusterStatus"
        }
      },
      "required": [
        "id",
        "clusterName",
        "googleProject",
        "googleServiceAccount",
        "machineConfig",
        "status",
        "createdDate",
        "labels",
        "dateAccessed",
        "autopauseThreshold",
        "defaultClientId",
        "scopes"
      ]
    },
    "ClusterError": {
      "description": "Errors encountered on cluster create",
      "properties": {
        "errorCode": {
          "description": "Error code",
          "type": "integer"
        },
        "errorMessage": {
          "description": "Error message",
          "type": "string"
        },
        "timestamp": {
          "description": "timestamp for error in ISO 8601 format",
          "type": "string"
        }
      }
    },
    "ClusterRequest": {
      "description": "",
      "properties": {
        "allowStop": {
          "default": false,
          "description": "If true, leo will allow updates that require a stop for this cluster. This flag should not be used at the time of cluster creation, but should be specified in the payload for the patch endpoint.",
          "type": "boolean"
        },
        "autopause": {
          "description": "Whether autopause feature is enabled for this specific cluster. If unset, autopause will be enabled and a system default threshold will be used.",
          "type": "boolean"
        },
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the cluster is autopaused. If autopause is set to false, this value is disregarded. A value of 0 is equivalent to autopause being turned off. If autopause is enabled and this is unset, a system default threshold will be used.",
          "type": "integer"
        },
        "customClusterEnvironmentVariables": {
          "description": "Optional environment variables to be set on the cluster.",
          "type": "object"
        },
        "defaultClientId": {
          "description": "The default Google Client ID.",
          "type": "string"
        },
        "enableWelder": {
          "default": true,
          "description": "If set to true, sets up welder on the cluster. If unset, welder will not be put on the cluster.",
          "type": "boolean"
        },
        "jupyterDockerImage": {
          "description": "Deprecated. Please use toolDockerImage.",
          "type": "string"
        },
        "jupyterExtensionUri": {
          "description": "Deprecated. Please use userJupyterExtensionConfig.",
          "type": "string"
        },
        "jupyterStartUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run on cluster start inside\nthe jupyter docker. In contrast to jupyterUserScriptUri, this always runs before starting\nJupyter, both on initial cluster creation and on cluster resume (jupyterUserScriptUri runs\nonce on cluster creation). This script may be used to launch background processes which\nwould not otherwise survive a cluster stop/start.\nThe script is pulled once at cluster creation time; subsequent client changes to the user\nscript at this URI do not affect the cluster. Timestamped logs for this script can be\nfound in the Leo staging bucket for the cluster. Script is run as root and docker --privileged.\n",
          "type": "string"
        },
        "jupyterUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run inside their jupyter\ndocker. This script runs exactly once when the cluster is first initialized. Logs from\nthis script can be found in the Leo staging bucket for the cluster. Script is run as root\nand docker --privileged.\n",
          "type": "string"
        },
        "labels": {
          "description": "The labels to be placed on the cluster. Of type Map[String,String]",
          "type": "object"
        },
        "machineConfig": {
          "$ref": "#/definitions/MachineConfig"
        },
        "scopes": {
          "default": [
            "https://www.googleapis.com/auth/userinfo.email",
            "https://www.googleapis.com/auth/userinfo.profile",
            "https://www.googleapis.com/auth/bigquery",
            "https://www.googleapis.com/auth/source.read_only"
          ],
          "description": "The scopes for the cluster. Defaults (userinfo.email, userinfo.profile, bigquery, source.read_only) will be used if left blank. Important: If you choose to specify custom scopes, the defaults will be overwritten. Thus, if you need the defaults, you will need to include the default scopes in your custom list of scopes.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "stopAfterCreation": {
          "default": false,
          "description": "If true, Leo will immediately stop the cluster once it's created, with the end result being a\na cluster in Stopped state. Otherwise, the end result will be a cluster in Running state.\nDefaults to false.\n",
          "type": "boolean"
        },
        "toolDockerImage": {
          "description": "The tool docker image to install. May be Dockerhub or GCR. If not set, a default Jupyter image will be installed.",
          "type": "string"
        },
        "userJupyterExtensionConfig": {
          "$ref": "#/definitions/UserJupyterExtensionConfig"
        },
        "welderDockerImage": {
          "description": "The Welder docker image to install. Only takes effect if the tool being installed supports welder.\nMay be Dockerhub or GCR. If not set, then a default Welder image will be installed.\n",
          "type": "string"
        },
        "welderRegistry": {
          "description": "The container registry from which to pull the latest version of welder.",
          "enum": [
            "GCR",
            "DockerHub"
          ],
          "type": "string"
        }
      }
    },
    "ClusterStatus": {
      "enum": [
        "Creating",
        "Running",
        "Updating",
        "Error",
        "Stopping",
        "Stopped",
        "Starting",
        "Deleting",
        "Deleted",
        "Unknown"
      ],
      "type": "string"
    },
    "CreateAppRequest": {
      "description": "the configuration of an app, used to create an app",
      "properties": {
        "appType": {
          "description": "currently only \"GALAXY\" is supported",
          "type": "string"
        },
        "diskConfig": {
          "$ref": "#/definitions/PersistentDiskRequest"
        },
        "kubernetesRuntimeConfig": {
          "$ref": "#/definitions/KubernetesRuntimeConfig"
        },
        "labels": {
          "description": "The labels to be placed on the cluster. Of type Map[String,String]",
          "type": "object"
        }
      },
      "type": "object"
    },
    "CreateDiskRequest": {
      "description": "Creates a new persistent disk",
      "properties": {
        "blockSize": {
          "description": "The block size of the persistent disk to be created in bytes.",
          "type": "integer"
        },
        "diskType": {
          "allOf": [
            {
              "$ref": "#/definitions/DiskType"
            },
            {
              "description": "The type of the persistent disk to be created. Can be \"Standard\" or \"SSD\"."
            }
          ]
        },
        "labels": {
          "description": "The labels to be placed on the persistent disk. Of type Map[String,String]",
          "type": "object"
        },
        "size": {
          "description": "The size of the persistent disk to be created in GB.",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "CreateRuntimeRequest": {
      "description": "Creates a new runtime",
      "properties": {
        "autopause": {
          "description": "Whether autopause feature is enabled for this specific cluster. If unset, autopause will be enabled and a system default threshold will be used.",
          "type": "boolean"
        },
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the cluster is autopaused. If autopause is set to false, this value is disregarded. A value of 0 is equivalent to autopause being turned off. If autopause is enabled and this is unset, a system default threshold will be used.",
          "type": "integer"
        },
        "customEnvironmentVariables": {
          "description": "Optional environment variables to be set on the cluster.",
          "type": "object"
        },
        "defaultClientId": {
          "description": "The default Google Client ID.",
          "type": "string"
        },
        "jupyterStartUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run on cluster start inside the jupyter docker. In contrast to jupyterUserScriptUri, this always runs before starting Jupyter, both on initial cluster creation and on cluster resume (jupyterUserScriptUri runs once on cluster creation). This script may be used to launch background processes which would not otherwise survive a cluster stop/start. The script is pulled once at cluster creation time; subsequent client changes to the user script at this URI do not affect the cluster. Timestamped logs for this script can be found in the Leo staging bucket for the cluster. Script is run as root and docker --privileged.\n",
          "type": "string"
        },
        "jupyterUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run inside their jupyter docker. This script runs exactly once when the cluster is first initialized. Logs from this script can be found in the Leo staging bucket for the cluster. Script is run as root and docker --privileged.\n",
          "type": "string"
        },
        "labels": {
          "description": "The labels to be placed on the runtime. Of type Map[String,String]",
          "type": "object"
        },
        "runtimeConfig": {},
        "scopes": {
          "default": [
            "https://www.googleapis.com/auth/userinfo.email",
            "https://www.googleapis.com/auth/userinfo.profile",
            "https://www.googleapis.com/auth/bigquery",
            "https://www.googleapis.com/auth/source.read_only"
          ],
          "description": "The scopes for the cluster. Defaults (userinfo.email, userinfo.profile, bigquery, source.read_only) will be used if left blank. Important: If you choose to specify custom scopes, the defaults will be overwritten. Thus, if you need the defaults, you will need to include the default scopes in your custom list of scopes.\n",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "toolDockerImage": {
          "description": "The tool docker image to install. May be Dockerhub or GCR. If not set, a default Jupyter image will be installed.",
          "type": "string"
        },
        "userJupyterExtensionConfig": {
          "$ref": "#/definitions/UserJupyterExtensionConfig"
        },
        "welderDockerImage": {
          "description": "The Welder docker image to install. Only takes effect if the tool being installed supports welder.\nMay be Dockerhub or GCR. If not set, then a default Welder image will be installed.\n",
          "type": "string"
        },
        "welderRegistry": {
          "description": "The container registry from which to pull the latest version of welder.",
          "enum": [
            "GCR",
            "DockerHub"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "DiskConfig": {
      "description": "The configuration of a persistent disk, returned in runtime responses",
      "properties": {
        "blockSize": {
          "description": "Block size of persistent disk in bytes",
          "type": "integer"
        },
        "diskType": {
          "$ref": "#/definitions/DiskType"
        },
        "name": {
          "description": "Name of the persistent disk",
          "type": "string"
        },
        "size": {
          "description": "Size of persistent disk in GB",
          "type": "integer"
        }
      },
      "required": [
        "name",
        "size",
        "diskType",
        "blockSize"
      ],
      "type": "object"
    },
    "DiskStatus": {
      "enum": [
        "Creating",
        "Restoring",
        "Failed",
        "Ready",
        "Deleting",
        "Deleted"
      ],
      "type": "string"
    },
    "DiskType": {
      "enum": [
        "pd-standard",
        "pd-ssd"
      ],
      "type": "string"
    },
    "ErrorReport": {
      "description": "",
      "properties": {
        "causes": {
          "description": "errors triggering this one",
          "items": {
            "$ref": "#/definitions/ErrorReport"
          },
          "type": "array"
        },
        "exceptionClass": {
          "description": "class of exception thrown",
          "type": "string"
        },
        "message": {
          "description": "what went wrong",
          "type": "string"
        },
        "source": {
          "description": "service causing error",
          "type": "string"
        },
        "stackTrace": {
          "description": "stack trace",
          "items": {
            "$ref": "#/definitions/StackTraceElement"
          },
          "type": "array"
        },
        "statusCode": {
          "description": "HTTP status code",
          "type": "integer"
        }
      },
      "required": [
        "source",
        "message",
        "causes",
        "stackTrace"
      ]
    },
    "GceConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/RuntimeConfig"
        },
        {
          "properties": {
            "bootDiskSize": {
              "description": "size for boot disk. For old runtimes (prior 6/22/2020, gce runtimes don't have a separate boot disk)",
              "type": "integer"
            },
            "diskSize": {
              "description": "Optional, the size in gigabytes of the disk on the GCE VM. Minimum size is 50GB. If unspecified, default size is 100GB.\n",
              "type": "integer"
            },
            "machineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the master node. For example \"n1-standard-16\"\nor \"n1-highmem-64\". If unspecified, defaults to creating a \"n1-standard-4\" machine. To decide which is right for you,\nsee https://cloud.google.com/compute/docs/machine-types\n",
              "type": "string"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration for Google Compute Engine instances."
    },
    "GceWithPdConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/RuntimeConfig"
        },
        {
          "properties": {
            "bootDiskSize": {
              "description": "size for boot disk",
              "type": "integer"
            },
            "machineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the master node. For example \"n1-standard-16\"\nor \"n1-highmem-64\". If unspecified, defaults to creating a \"n1-standard-4\" machine. To decide which is right for you,\nsee https://cloud.google.com/compute/docs/machine-types\n",
              "type": "string"
            },
            "persistentDisk": {
              "$ref": "#/definitions/PersistentDiskRequest"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration for Google Compute Engine instances."
    },
    "GetAppResponse": {
      "description": "the configuration of an app",
      "properties": {
        "diskName": {
          "description": "the name of the disk associated with this app",
          "type": "string"
        },
        "errors": {
          "description": "The list of errors that the app has encountered.",
          "items": {
            "$ref": "#/definitions/KubernetesError"
          },
          "type": "array"
        },
        "kubernetesRuntimeConfig": {
          "$ref": "#/definitions/KubernetesRuntimeConfig"
        },
        "proxyUrls": {
          "description": "map of service name to proxyUrl",
          "type": "object"
        },
        "status": {
          "$ref": "#/definitions/AppStatus"
        }
      },
      "type": "object"
    },
    "GetPersistentDiskResponse": {
      "description": "",
      "properties": {
        "auditInfo": {
          "$ref": "#/definitions/AuditInfo"
        },
        "blockSize": {
          "description": "Block size of persistent disk in bytes",
          "type": "integer"
        },
        "diskType": {
          "$ref": "#/definitions/DiskType"
        },
        "googleId": {
          "description": "Google's UUID for the persistent disk",
          "type": "string"
        },
        "googleProject": {
          "description": "The google project used to create the persistent disk",
          "type": "string"
        },
        "id": {
          "description": "Internal Leonardo ID of the persistent disk",
          "type": "integer"
        },
        "labels": {
          "description": "The labels to be placed on the persistent disk. Of type Map[String,String]",
          "type": "object"
        },
        "name": {
          "description": "The user-supplied name of the persistent disk",
          "type": "string"
        },
        "samResourceId": {
          "description": "Internal resource ID of the persistent disk",
          "type": "string"
        },
        "size": {
          "description": "Size of persistent disk in GB",
          "type": "integer"
        },
        "status": {
          "$ref": "#/definitions/DiskStatus"
        },
        "zone": {
          "description": "The google zone in which the persistent disk was created",
          "type": "string"
        }
      },
      "required": [
        "id",
        "googleProject",
        "zone",
        "name",
        "googleId",
        "samResourceId",
        "status",
        "auditInfo",
        "size",
        "diskType",
        "blockSize",
        "labels"
      ]
    },
    "GetRuntimeResponse": {
      "description": "",
      "properties": {
        "asyncRuntimeFields": {
          "$ref": "#/definitions/AsyncRuntimeFields"
        },
        "auditInfo": {
          "$ref": "#/definitions/AuditInfo"
        },
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the runtime is autopaused. A value of 0 is equivalent to autopause being turned off.",
          "type": "integer"
        },
        "customEnvironmentVariables": {
          "description": "Optional environment variables to be set on the runtime.",
          "type": "object"
        },
        "defaultClientId": {
          "description": "The default Google Client ID.",
          "type": "string"
        },
        "diskConfig": {
          "$ref": "#/definitions/DiskConfig"
        },
        "errors": {
          "description": "The list of errors that were encountered on runtime create. Each error consists of the error message, code and timestamp",
          "items": {
            "$ref": "#/definitions/ClusterError"
          },
          "type": "array"
        },
        "googleProject": {
          "description": "The Google Project used to create the runtime",
          "type": "string"
        },
        "id": {
          "description": "The leonardo ID of the runtime",
          "type": "integer"
        },
        "jupyterStartUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run on cluster start inside\nthe jupyter docker. In contrast to jupyterUserScriptUri, this always runs before starting\nJupyter, both on initial cluster creation and on cluster resume (jupyterUserScriptUri runs\nonce on cluster creation). This script may be used to launch background processes which\nwould not otherwise survive a cluster stop/start.\nThe script is pulled once at cluster creation time; subsequent client changes to the user\nscript at this URI do not affect the cluster. Timestamped logs for this script can be\nfound in the Leo staging bucket for the cluster. Script is run as root and docker --privileged.\n",
          "type": "string"
        },
        "jupyterUserScriptUri": {
          "description": "Optional GCS object URI to a bash script the user wishes to run inside their jupyter\ndocker. This script runs exactly once when the cluster is first initialized. Logs from\nthis script can be found in the Leo staging bucket for the cluster. Script is run as root\nand docker --privileged.\n",
          "type": "string"
        },
        "labels": {
          "description": "The labels to be placed on the runtime. Of type Map[String,String]",
          "type": "object"
        },
        "proxyUrl": {
          "description": "The URL to access a tool on the runtime",
          "type": "string"
        },
        "runtimeConfig": {
          "$ref": "#/definitions/MachineConfig"
        },
        "runtimeImages": {
          "description": "The docker images on the runtime",
          "items": {
            "$ref": "#/definitions/RuntimeImage"
          },
          "type": "array"
        },
        "runtimeName": {
          "description": "The user-supplied name for the runtime",
          "type": "string"
        },
        "scopes": {
          "description": "The scopes for the runtime.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "serviceAccount": {
          "description": "The Google Service Account used to create the runtime",
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/ClusterStatus"
        },
        "userJupyterExtensionConfig": {
          "$ref": "#/definitions/UserJupyterExtensionConfig"
        }
      },
      "required": [
        "id",
        "runtimeName",
        "googleProject",
        "serviceAccount",
        "auditInfo",
        "runtimeConfig",
        "status",
        "labels",
        "autopauseThreshold",
        "defaultClientId",
        "scopes"
      ]
    },
    "Instance": {
      "description": "",
      "properties": {
        "createdDate": {
          "description": "The date and time the instance was created, in ISO-8601 format",
          "type": "string"
        },
        "dataprocRole": {
          "description": "The dataproc role (master, worker, preemptible worker) of this instance, if any",
          "type": "string"
        },
        "googleId": {
          "description": "Google's unique id for this instance",
          "type": "string"
        },
        "ip": {
          "description": "The public IP address of the instance, if any",
          "type": "string"
        },
        "key": {
          "$ref": "#/definitions/InstanceKey"
        },
        "status": {
          "$ref": "#/definitions/InstanceStatus"
        }
      },
      "required": [
        "key",
        "googleId",
        "status"
      ]
    },
    "InstanceKey": {
      "description": "",
      "properties": {
        "name": {
          "description": "The name of the instance",
          "type": "string"
        },
        "project": {
          "description": "The Google Project the instance belongs to",
          "type": "string"
        },
        "zone": {
          "description": "The Google zone the instance belongs to",
          "type": "string"
        }
      },
      "required": [
        "project",
        "zone",
        "name"
      ]
    },
    "InstanceStatus": {
      "enum": [
        "Provisioning",
        "Staging",
        "Running",
        "Stopping",
        "Stopped",
        "Suspending",
        "Suspended",
        "Terminated"
      ],
      "type": "string"
    },
    "KubernetesError": {
      "description": "a kubernetes app error",
      "properties": {
        "action": {
          "description": "the api-level action associated with the error, e.g. createApp",
          "type": "string"
        },
        "errorMessage": {
          "description": "a helpful error message",
          "type": "string"
        },
        "googleErrorCode": {
          "description": "if the error is associated with an external API call, the error code will be propagated here",
          "type": "integer"
        },
        "source": {
          "description": "the internal source associated with the error",
          "type": "string"
        },
        "timestamp": {
          "description": "timestamp for error in ISO 8601 format",
          "type": "string"
        }
      },
      "type": "object"
    },
    "KubernetesRuntimeConfig": {
      "description": "configuration for a kubernetes app runtime",
      "properties": {
        "autoscalingEnabled": {
          "description": "whether or not the nodes autoscale up and down for this app",
          "type": "boolean"
        },
        "machineType": {
          "description": "the machine type for the nodes the kubernetes app will run on",
          "example": "n1-standard-1",
          "type": "string"
        },
        "numNodes": {
          "description": "number of nodes for the kubernetes app",
          "type": "integer"
        }
      },
      "required": [
        "numNodes",
        "machineType",
        "autoscalingEnabled"
      ],
      "type": "object"
    },
    "LeonardoVersion": {
      "properties": {
        "version": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ListAppResponse": {
      "description": "the configuration of an app",
      "properties": {
        "appName": {
          "description": "the name of the app",
          "type": "string"
        },
        "diskName": {
          "description": "the name of the disk associated with this app",
          "type": "string"
        },
        "errors": {
          "description": "The list of errors that the app has encountered.",
          "items": {
            "$ref": "#/definitions/KubernetesError"
          },
          "type": "array"
        },
        "googleProject": {
          "description": "the project this app is associated with",
          "type": "string"
        },
        "kubernetesRuntimeConfig": {
          "$ref": "#/definitions/KubernetesRuntimeConfig"
        },
        "proxyUrls": {
          "description": "map of service name to proxyUrl",
          "type": "object"
        },
        "status": {
          "$ref": "#/definitions/AppStatus"
        }
      },
      "type": "object"
    },
    "ListClusterResponse": {
      "description": "",
      "properties": {
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the cluster is autopaused. A value of 0 is equivalent to autopause being turned off.",
          "type": "integer"
        },
        "clusterName": {
          "description": "The user-supplied name for the cluster",
          "type": "string"
        },
        "createdDate": {
          "description": "The date and time the cluster was created, in ISO-8601 format",
          "type": "string"
        },
        "dateAccessed": {
          "description": "The date and time the cluster was last accessed, in ISO-8601 format.\nDate accessed is defined as the last time the cluster was created, modified, or accessed via the proxy.\n",
          "type": "string"
        },
        "defaultClientId": {
          "description": "The default Google Client ID.",
          "type": "string"
        },
        "destroyedDate": {
          "description": "The date and time the cluster was destroyed, in ISO-8601 format",
          "type": "string"
        },
        "googleId": {
          "description": "Google's UUID for the cluster",
          "type": "string"
        },
        "googleProject": {
          "description": "The Google Project used to create the cluster",
          "type": "string"
        },
        "googleServiceAccount": {
          "description": "The Google Service Account used to create the cluster",
          "type": "string"
        },
        "hostIp": {
          "description": "The IP address of the cluster master node",
          "type": "string"
        },
        "instances": {
          "description": "Array of instances belonging to this cluster",
          "items": {
            "$ref": "#/definitions/Instance"
          },
          "type": "array"
        },
        "internalId": {
          "description": "Internal resource ID of the cluster",
          "type": "string"
        },
        "jupyterUserScriptUri": {
          "type": "string"
        },
        "labels": {
          "description": "The labels to be placed on the cluster. Of type Map[String,String]",
          "type": "object"
        },
        "machineConfig": {
          "$ref": "#/definitions/MachineConfig"
        },
        "operationName": {
          "description": "Google's operation ID for the cluster",
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/ClusterStatus"
        }
      },
      "required": [
        "clusterName",
        "googleProject",
        "googleServiceAccount",
        "machineConfig",
        "status",
        "createdDate",
        "labels",
        "dateAccessed",
        "autopauseThreshold",
        "defaultClientId"
      ]
    },
    "ListPersistentDiskResponse": {
      "description": "",
      "properties": {
        "auditInfo": {
          "$ref": "#/definitions/AuditInfo"
        },
        "blockSize": {
          "description": "Block size of persistent disk in bytes",
          "type": "integer"
        },
        "diskType": {
          "$ref": "#/definitions/DiskType"
        },
        "googleProject": {
          "description": "The google project used to create the persistent disk",
          "type": "string"
        },
        "id": {
          "description": "Internal Leonardo ID of the persistent disk",
          "type": "integer"
        },
        "name": {
          "description": "The user-supplied name of the persistent disk",
          "type": "string"
        },
        "size": {
          "description": "Size of persistent disk in GB",
          "type": "integer"
        },
        "status": {
          "$ref": "#/definitions/DiskStatus"
        },
        "zone": {
          "description": "The google zone in which the persistent disk was created",
          "type": "string"
        }
      },
      "required": [
        "id",
        "googleProject",
        "zone",
        "name",
        "status",
        "auditInfo",
        "size",
        "diskType",
        "blockSize"
      ]
    },
    "ListRuntimeResponse": {
      "description": "",
      "properties": {
        "diskConfig": {
          "$ref": "#/definitions/DiskConfig"
        },
        "googleProject": {
          "description": "The Google Project used to create the runtime",
          "type": "string"
        },
        "id": {
          "description": "Internal Leonardo ID of the runtime",
          "type": "integer"
        },
        "labels": {
          "description": "The labels to be placed on the runtime. Of type Map[String,String]",
          "type": "object"
        },
        "patchInProgress": {
          "description": "Whether there is a patch in progress on the runtime. Is used to indicate updates that require status transitions.",
          "type": "boolean"
        },
        "proxyUrl": {
          "description": "The URL to access a tool on the runtime",
          "type": "string"
        },
        "runtimeConfig": {
          "$ref": "#/definitions/MachineConfig"
        },
        "runtimeName": {
          "description": "The user-supplied name for the runtime",
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/ClusterStatus"
        }
      },
      "required": [
        "id",
        "runtimeName",
        "googleProject",
        "serviceAccount",
        "runtimeConfig",
        "status",
        "labels"
      ]
    },
    "MachineConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/RuntimeConfig"
        },
        {
          "properties": {
            "masterDiskSize": {
              "description": "Optional, the size in gigabytes of the disk on the master node. Minimum size is 50GB. If unspecified, default size is 100GB.\n",
              "type": "integer"
            },
            "masterMachineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the master node. For example \"n1-standard-16\"\nor \"n1-highmem-64\". If unspecified, defaults to creating a \"n1-standard-4\" machine. To decide which is right for you,\nsee https://cloud.google.com/compute/docs/machine-types\n",
              "type": "string"
            },
            "numberOfPreemptibleWorkers": {
              "description": "Optional, the number of preemptible workers. If unspecified, the default number is 0. Ignored if numberOfWorkers is 0.\nFor more information, see https://cloud.google.com/compute/docs/instances/preemptible\n",
              "type": "integer"
            },
            "numberOfWorkerLocalSSDs": {
              "description": "Optional, the number of local solid state disks for workers. If unspecified, the default number is 0.\nIgnored if numberOfWorkers is 0.\n",
              "type": "integer"
            },
            "numberOfWorkers": {
              "description": "Optional, number of workers in the cluster. Can be 0 (default), 2 or more. Google Dataproc does not allow 1 worker.\n",
              "type": "integer"
            },
            "properties": {
              "additionalProperties": {
                "type": "string"
              },
              "description": "Example {\"spark:spark.executor.memory\": \"10g\"}. See https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/cluster-properties for allowed property settings\n",
              "type": "object"
            },
            "workerDiskSize": {
              "description": "Optional, the size in gigabytes of the disk on the master node. Minimum size is 10GB. If unspecified, default size is 100GB.\nIgnored if numberOfWorkers is 0.\n",
              "type": "integer"
            },
            "workerMachineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the worker nodes. For example \"n1-standard-16\"\nor \"n1-highmem-64\". If unspecified, defaults to creating a \"n1-standard-4\" machine. To decide which is right for you,\nsee https://cloud.google.com/compute/docs/machine-types. Ignored if numberOfWorkers is 0.\n",
              "type": "string"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration for a single Dataproc cluster."
    },
    "PersistentDiskRequest": {
      "description": "configuration to create a disk",
      "properties": {
        "diskType": {
          "$ref": "#/definitions/DiskType"
        },
        "labels": {
          "description": "The labels to be placed on the cluster. Of type Map[String,String]",
          "type": "object"
        },
        "name": {
          "description": "The name of the disk. This can reference an existing disk.",
          "type": "string"
        },
        "size": {
          "description": "the size of the disk, if this is a creation request. Has an intelligent default otherwise",
          "type": "integer"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "RuntimeConfig": {
      "properties": {
        "cloudService": {
          "enum": [
            "gce",
            "dataproc"
          ],
          "type": "string"
        }
      },
      "required": [
        "cloudService"
      ],
      "type": "object"
    },
    "RuntimeImage": {
      "properties": {
        "imageType": {
          "description": "The container this image supports. Ex Jupyter, Proxy, VM",
          "type": "string"
        },
        "imageUrl": {
          "description": "The place this image can be pulled from",
          "type": "string"
        },
        "timestamp": {
          "description": "timestamp for image addition to the runtime in ISO 8601 format",
          "type": "string"
        }
      },
      "type": "object"
    },
    "StackTraceElement": {
      "description": "",
      "properties": {
        "className": {
          "description": "class name",
          "type": "string"
        },
        "fileName": {
          "description": "source file name",
          "type": "string"
        },
        "lineNumber": {
          "description": "line number",
          "type": "integer"
        },
        "methodName": {
          "description": "method name",
          "type": "string"
        }
      },
      "required": [
        "className",
        "methodName",
        "fileName",
        "lineNumber"
      ]
    },
    "SystemStatus": {
      "description": "status of each subsystem Leonardo depends on",
      "properties": {
        "ok": {
          "description": "true if everything is ok, false if anything is amiss",
          "type": "boolean"
        },
        "systems": {
          "description": "Map[String, SubsystemStatus]",
          "type": "object"
        }
      },
      "required": [
        "ok",
        "systems"
      ],
      "type": "object"
    },
    "UpdateDataprocConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/UpdateRuntimeConfig"
        },
        {
          "properties": {
            "masterDiskSize": {
              "description": "Optional, disk size of the master node in gigabytes\n",
              "type": "integer"
            },
            "masterMachineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the cluster master node. For example \"n1-standard-16\" or \"n1-highmem-64\". To decide which is right for you, see https://cloud.google.com/compute/docs/machine-types\n",
              "type": "string"
            },
            "numberOfPreemptibleWorkers": {
              "description": "Optional, number of preemptible workers in the cluster\n",
              "type": "integer"
            },
            "numberOfWorkers": {
              "description": "Optional, number of workers in the cluster\n",
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration for Google Dataproc clusters."
    },
    "UpdateDiskRequest": {
      "description": "Updates an existing persistent disk",
      "properties": {
        "blockSize": {
          "description": "The block size in bytes that the persistent disk is to be updated to.",
          "type": "integer"
        },
        "diskType": {
          "$ref": "#/definitions/DiskType"
        },
        "labels": {
          "description": "The labels to be added or updated on the persistent disk. Of type Map[String,String]",
          "type": "object"
        },
        "size": {
          "description": "The size in GB that the persistent disk is to be updated to.",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "UpdateGceConfig": {
      "allOf": [
        {
          "$ref": "#/definitions/UpdateRuntimeConfig"
        },
        {
          "properties": {
            "diskSize": {
              "description": "Optional, disk size in gigabytes\n",
              "type": "integer"
            },
            "machineType": {
              "description": "Optional, the machine type determines the number of CPUs and memory for the instance. For example \"n1-standard-16\" or \"n1-highmem-64\". To decide which is right for you, see https://cloud.google.com/compute/docs/machine-types\n",
              "type": "string"
            }
          },
          "type": "object"
        }
      ],
      "description": "Configuration for Google Compute Engine instances."
    },
    "UpdateRuntimeConfig": {
      "description": "Updates a runtime configuration",
      "properties": {
        "cloudService": {
          "enum": [
            "gce",
            "dataproc"
          ],
          "type": "string"
        }
      },
      "required": [
        "cloudService"
      ],
      "type": "object"
    },
    "UpdateRuntimeRequest": {
      "description": "Updates a runtime",
      "properties": {
        "allowStop": {
          "description": "Whether leo should stop the runtime if it is necessary for the update. If false, an exception will be thrown in cases where a stop was required. Defaults to false.",
          "type": "boolean"
        },
        "autopause": {
          "description": "Whether autopause feature is enabled for this specific cluster.",
          "type": "boolean"
        },
        "autopauseThreshold": {
          "description": "The number of minutes of idle time to elapse before the cluster is autopaused. If autopause is set to false, this value is disregarded. A value of 0 is equivalent to autopause being turned off.",
          "type": "integer"
        },
        "runtimeConfig": {}
      },
      "type": "object"
    },
    "UserJupyterExtensionConfig": {
      "description": "Specification of Jupyter Extensions to be installed on the cluster",
      "properties": {
        "combinedExtensions": {
          "description": "Optional, map of extension name and notebook plus server extension. The extension can either be a tar.gz file on google storage or a python package.\nExample, {\"ext1\":\"gs://bucket/extension.tar.gz\", \"ext2\":\"python-package\"}\n",
          "type": "object"
        },
        "labExtensions": {
          "description": "Optional, map of extension name and lab extension. The extension should be a verified jupyterlab extension that is uploaded to npm (list of public extensions here: https://github.com/search?utf8=%E2%9C%93&q=topic%3Ajupyterlab-extension&type=Repositories), a gzipped tarball made using 'npm pack', a folder structured by 'jlpm build', a JS file to be inserted into an JL extension template (see https://github.com/jupyterlab/extension-cookiecutter-js), or a URL to one of the last three options.\n",
          "type": "object"
        },
        "nbExtensions": {
          "description": "Optional, map of extension name and nbExtension. The nbExtension can either be a tar.gz or .js file, either on google storage or at a URL, or a python package.\nAn archive must not include a parent directory, and must have an entry point named 'main'.\nFor more information on notebook extensions, see http://jupyter-notebook.readthedocs.io/en/latest/extending/frontend_extensions.html.\nExample, {\"ext1\":\"gs://bucket/extension.tar.gz\", \"ext2\":\"python-package\",  \"ext3\":\"http://foo.com/extension.js\"}\n",
          "type": "object"
        },
        "serverExtensions": {
          "description": "Optional, map of extension name and server extension. The serverExtensions can either be a tar.gz file on google storage or a python package.\nExample, {\"ext1\":\"gs://bucket/extension.tar.gz\", \"ext2\":\"python-package\"}\n",
          "type": "object"
        }
      }
    }
  },
  "securityDefinitions": {
    "googleoauth": {
      "authorizationUrl": "https://accounts.google.com/o/oauth2/auth",
      "flow": "implicit",
      "scopes": {
        "email": "email authorization",
        "openid": "open id authorization",
        "profile": "profile authorization"
      },
      "type": "oauth2"
    }
  },
  "security": [
    {
      "googleoauth": [
        "openid",
        "email",
        "profile"
      ]
    }
  ],
  "tags": [
    {
      "description": "Runtimes API. Support both Google Dataproc and Google Compute Engine.",
      "name": "runtimes"
    },
    {
      "description": "Persistent Disks API.",
      "name": "disks"
    },
    {
      "description": "Experimental App API",
      "name": "apps"
    },
    {
      "description": "Legacy Clusters API. Supports Google Dataproc only.",
      "name": "cluster"
    },
    {
      "description": "Proxy API",
      "name": "proxy"
    },
    {
      "description": "Notebooks API. Deprecated in favor of Proxy API.",
      "name": "notebooks"
    },
    {
      "description": "Service Info API",
      "name": "service_info"
    }
  ],
  "x-components": {
    "requestBodies": {
      "BatchNodepoolCreateRequest": {
        "content": {
          "application/json": {
            "example": {
              "numNodepools": 10
            },
            "schema": {
              "$ref": "#/definitions/BatchNodepoolCreateRequest"
            }
          }
        }
      },
      "ClusterRequest": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/definitions/ClusterRequest"
            }
          }
        },
        "description": "Request for new cluster",
        "required": true
      },
      "CreateAppRequest": {
        "content": {
          "application/json": {
            "example": {
              "diskConfig": {
                "name": "disk1"
              }
            },
            "schema": {
              "$ref": "#/definitions/CreateAppRequest"
            }
          }
        }
      },
      "CreateDiskRequest": {
        "content": {
          "application/json": {
            "example": {
              "blockSize": 4096,
              "diskType": "pd-standard",
              "size": 500
            },
            "schema": {
              "$ref": "#/definitions/CreateDiskRequest"
            }
          }
        }
      },
      "CreateRuntimeRequest": {
        "content": {
          "application/json": {
            "example": {
              "runtimeConfig": {
                "cloudService": "gce",
                "diskSize": 100,
                "machineType": "n1-standard-4"
              }
            },
            "schema": {
              "$ref": "#/definitions/CreateRuntimeRequest"
            }
          }
        }
      },
      "UpdateDiskRequest": {
        "content": {
          "application/json": {
            "example": {
              "size": 600
            },
            "schema": {
              "$ref": "#/definitions/UpdateDiskRequest"
            }
          }
        }
      },
      "UpdateRuntimeRequest": {
        "content": {
          "application/json": {
            "example": {
              "allowStop": true,
              "runtimeConfig": {
                "cloudService": "gce",
                "diskSize": 500,
                "machineType": "n1-highmem-16"
              }
            },
            "schema": {
              "$ref": "#/definitions/UpdateRuntimeRequest"
            }
          }
        }
      }
    }
  }
}
