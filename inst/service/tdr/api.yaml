{
  "swagger": "2.0",
  "info": {
    "description": "<details><summary>This document defines the REST API for the Terra Data Repository.</summary> <p> **Status: design in progress**\nThere are a few top-level endpoints (besides some used by swagger):\n * / - generated by swagger: swagger API page that provides this\ndocumentation and a live UI for submitting REST requests\n * /status - provides the operational status of the service\n * /configuration - provides the basic configuration and information about the service\n * /api - is the authenticated and authorized Data Repository API\n * /ga4gh/drs/v1 - is a transcription of the Data Repository Service API\n\nThe API endpoints are organized by interface. Each interface is separately versioned. <p> **Notes on Naming** <p> All of the reference items are suffixed with \\\"Model\\\". Those names are used as the class names in the generated Java code. It is helpful to distinguish these model classes from other related classes, like the DAO classes and the operation classes. </details>\n",
    "license": {
      "name": "Apache 2.0",
      "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "termsOfService": "https://app.terra.bio/#terms-of-service",
    "title": "Data Repository API",
    "version": "0.1.0"
  },
  "basePath": "/",
  "paths": {
    "/api/repository/v1/admin/register-drs-aliases": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "schema": {
              "items": {
                "$ref": "#/definitions/DrsAliasModel"
              },
              "type": "array"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Drs alias registration job submitted",
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "admin",
          "repository"
        ],
        "description": "Load Drs Aliases into TDR.  It is possible to have an alias to a DRS ID that does not exist in TDR.\n",
        "operationId": "registerDrsAliases"
      }
    },
    "/api/repository/v1/configs": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "all configurations",
            "schema": {
              "$ref": "#/definitions/ConfigListModel"
            }
          }
        },
        "tags": [
          "configs",
          "repository"
        ],
        "description": "Get all configurations",
        "operationId": "getConfigList"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ConfigGroupModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "previous settings",
            "schema": {
              "$ref": "#/definitions/ConfigListModel"
            }
          },
          "400": {
            "description": "invalid configuration model",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "unknown configuration name(s) - see errorDetails",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "configs",
          "repository"
        ],
        "description": "Set the a group of configurations",
        "operationId": "setConfigList",
        "x-codegen-request-body-name": "configModel"
      }
    },
    "/api/repository/v1/configs/reset": {
      "put": {
        "parameters": [],
        "responses": {
          "204": {
            "description": "configuration reset"
          }
        },
        "tags": [
          "configs",
          "repository"
        ],
        "description": "Reset the configuration to original settings",
        "operationId": "resetConfig"
      }
    },
    "/api/repository/v1/configs/{name}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "name of the configuration to get",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "current configuration",
            "schema": {
              "$ref": "#/definitions/ConfigModel"
            }
          },
          "404": {
            "description": "unknown configuration name",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "configs",
          "repository"
        ],
        "description": "Get one configuration",
        "operationId": "getConfig"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "name of the configuration to",
            "in": "path",
            "name": "name",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/ConfigEnableModel"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "fault was en/dis-abled successfully - no content"
          },
          "400": {
            "description": "configuration name is not a fault",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "unknown configuration name",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "configs",
          "repository"
        ],
        "description": "Enable or disable the named fault. Performing the put on a config that is not a fault is an error.\n",
        "operationId": "setFault",
        "x-codegen-request-body-name": "configEnable"
      }
    },
    "/api/repository/v1/datasets": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "default": 0,
            "description": "The number of datasets to skip before when retrieving the next page",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers datasets to retrieve and return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          },
          {
            "default": "created_date",
            "description": "The field to use for sorting.",
            "enum": [
              "name",
              "description",
              "created_date"
            ],
            "in": "query",
            "name": "sort",
            "type": "string"
          },
          {
            "default": "asc",
            "description": "The direction to sort.",
            "enum": [
              "asc",
              "desc"
            ],
            "in": "query",
            "name": "direction",
            "type": "string"
          },
          {
            "description": "Filter the results where this string is a case insensitive match in the name or description.",
            "in": "query",
            "name": "filter",
            "type": "string"
          },
          {
            "description": "Filter the results where this string is a case insensitive match in any of the cloud storage regions used by the dataset.",
            "in": "query",
            "name": "region",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter the results where these case sensitive tags are applied to the datasets\n",
            "in": "query",
            "items": {
              "$ref": "#/definitions/Tag"
            },
            "name": "tags",
            "required": false,
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "List of datasets",
            "schema": {
              "$ref": "#/definitions/EnumerateDatasetModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Returns a list of all of the datasets the caller has access to\n",
        "operationId": "enumerateDatasets"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Dataset to create",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/DatasetRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for ingest complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of ingest job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - duplicate name, invalid name, badly formed schema",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to create datasets",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Create a new dataset asynchronously. The async result is DatasetSummaryModel.",
        "operationId": "createDataset",
        "x-codegen-request-body-name": "dataset"
      }
    },
    "/api/repository/v1/datasets/tags": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Filter to tags with this string as a case-insensitive match.",
            "in": "query",
            "name": "filter",
            "type": "string"
          },
          {
            "description": "The maximum number of tags to return, in descending order of occurrence count. All accessible tags will be returned if unspecified.\n",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "Accessible dataset tags matching specified filters.",
            "schema": {
              "$ref": "#/definitions/TagCountResultModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Get accessible dataset tags",
        "operationId": "getDatasetTags"
      }
    },
    "/api/repository/v1/datasets/{id}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for dataset successful deletion",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of dataset deletion job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to delete dataset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Dataset in use by at least one snapshot",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Delete a dataset by id",
        "operationId": "deleteDataset"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "default": "SCHEMA,PROFILE,DATA_PROJECT,STORAGE",
            "description": "A list of what to include with the dataset object",
            "in": "query",
            "items": {
              "$ref": "#/definitions/DatasetRequestAccessIncludeModel"
            },
            "name": "include",
            "required": false,
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset",
            "schema": {
              "$ref": "#/definitions/DatasetModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see dataset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve a dataset by id",
        "operationId": "retrieveDataset"
      },
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A 'lite' dataset definition (used to modify supported fields of a dataset). Null assignments will be ignored.",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/DatasetPatchRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Summary of updated dataset.",
            "schema": {
              "$ref": "#/definitions/DatasetSummaryModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed modification instructions.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist, missing permissions to modify.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - dataset was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Update supported fields of the specified dataset.",
        "operationId": "patchDataset"
      }
    },
    "/api/repository/v1/datasets/{id}/assets": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Asset definition to add to the dataset",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/AssetModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for ingest complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of ingest job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to add an asset to a dataset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Add an asset definiion to a dataset",
        "operationId": "addDatasetAssetSpecifications",
        "x-codegen-request-body-name": "assetModel"
      }
    },
    "/api/repository/v1/datasets/{id}/assets/{assetid}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "An asset id",
            "in": "path",
            "name": "assetid",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for ingest complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Add new assets to a dataset",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to remove an asset from a dataset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Remove an asset definition from a dataset",
        "operationId": "removeDatasetAssetSpecifications"
      }
    },
    "/api/repository/v1/datasets/{id}/data/{table}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table to get data from",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of rows to skip when retrieving the next page",
            "in": "query",
            "minimum": 0,
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 30,
            "description": "The number of rows to return for the data",
            "in": "query",
            "maximum": 1000,
            "minimum": 1,
            "name": "limit",
            "type": "integer"
          },
          {
            "default": "datarepo_row_id",
            "description": "The table column to sort by",
            "in": "query",
            "name": "sort",
            "type": "string"
          },
          {
            "default": "asc",
            "description": "The direction to sort.",
            "enum": [
              "asc",
              "desc"
            ],
            "in": "query",
            "name": "direction",
            "type": "string"
          },
          {
            "description": "A SQL WHERE clause to filter the table results.",
            "in": "query",
            "name": "filter",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the table data from a dataset",
            "schema": {
              "$ref": "#/definitions/DatasetDataModel"
            }
          }
        },
        "tags": [
          "datasets",
          "search",
          "repository"
        ],
        "deprecated": true,
        "description": "Retrieve data for a table in a dataset. This endpoint is deprecated, please use the POST version.",
        "operationId": "lookupDatasetDataById"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table to get data from",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "description": "Parameters to filter results",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/QueryDataRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the table data from a dataset",
            "schema": {
              "$ref": "#/definitions/DatasetDataModel"
            }
          }
        },
        "tags": [
          "datasets",
          "search",
          "repository"
        ],
        "description": "Retrieve data for a table in a dataset.",
        "operationId": "queryDatasetDataById"
      }
    },
    "/api/repository/v1/datasets/{id}/data/{table}/statistics/{column}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table where column lives",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of column in the table to get statistics about",
            "in": "path",
            "name": "column",
            "required": true,
            "type": "string"
          },
          {
            "description": "A SQL WHERE clause to filter results included in column statistics.\n\nFor GCP array string columns, if you wanted to include all rows that contain 'value1' in column1, the filter clause would look like 'WHERE 'value1' IN UNNEST(column1)'. Note that \"count\" value includes all occurrences of a value including duplicates of the same value in a single array. i.e. if we had two rows in a table where the value for column1, row1 = ['value1', 'value1', 'value2'] and column1, row2 = ['value1'] the count for 'value1' would be 3.",
            "in": "query",
            "name": "filter",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the statistics about a column from a dataset's table",
            "schema": {
              "$ref": "#/definitions/ColumnStatisticsModel"
            }
          }
        },
        "tags": [
          "datasets"
        ],
        "deprecated": true,
        "description": "Retrieve statistics about data for a column in a table in a dataset. This endpoint is deprecated, please use the POST version.",
        "operationId": "lookupDatasetColumnStatisticsById"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table where column lives",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of column in the table to get statistics about",
            "in": "path",
            "name": "column",
            "required": true,
            "type": "string"
          },
          {
            "description": "Parameters to filter results",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/QueryColumnStatisticsRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the statistics about a column from a dataset's table",
            "schema": {
              "$ref": "#/definitions/ColumnStatisticsModel"
            }
          }
        },
        "tags": [
          "datasets"
        ],
        "description": "Retrieve statistics about data for a column in a table in a dataset.",
        "operationId": "queryDatasetColumnStatisticsById"
      }
    },
    "/api/repository/v1/datasets/{id}/deletes": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Description of the data in the dataset to delete",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/DataDeletionRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Response",
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid tableName, bad row ids, badly formed, etc.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to delete data",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Applies deletes to primary tabular data in a dataset",
        "operationId": "applyDatasetDataDeletion",
        "x-codegen-request-body-name": "dataDeletionRequest"
      }
    },
    "/api/repository/v1/datasets/{id}/files": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "List of files",
            "schema": {
              "items": {
                "$ref": "#/definitions/FileModel"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "List metadata for all files in a dataset.",
        "operationId": "listFiles"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Ingest file request",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/FileLoadModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for ingest complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of ingest job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to ingest",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Ingest one file into the dataset file system; async returns a FileModel",
        "operationId": "ingestFile",
        "x-codegen-request-body-name": "ingestFile"
      }
    },
    "/api/repository/v1/datasets/{id}/files/bulk": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Bulk file load request with file list in an external file. Load summary results are returned in the async response.",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/BulkLoadRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for bulk load complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of bulk load job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to ingest",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Someone else is using the load tag",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Load many files into the dataset file system; async returns a BulkLoadResultModel Note that this endpoint is not a single transaction. Some files may be loaded and others may fail. Each file load is atomic; the file will either be loaded into the dataset file system or it will not exist.",
        "operationId": "bulkFileLoad",
        "x-codegen-request-body-name": "bulkFileLoad"
      }
    },
    "/api/repository/v1/datasets/{id}/files/bulk/array": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Bulk file load request with file list in the body of the request and load results returned in the async response.",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/BulkLoadArrayRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for bulk load complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of bulk load job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to ingest",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Someone else is using the load tag",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Load many files into the dataset file system; async returns a BulkLoadArrayResultModel Note that this endpoint is not a single transaction. Some files may be loaded and others may fail. Each file load is atomic; the file will either be loaded into the dataset file system or it will not exist.",
        "operationId": "bulkFileLoadArray",
        "x-codegen-request-body-name": "bulkFileLoadArray"
      }
    },
    "/api/repository/v1/datasets/{id}/files/bulk/{loadTag}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "a load tag",
            "in": "path",
            "name": "loadtag",
            "required": true,
            "type": "string"
          },
          {
            "description": "The job id associated with the load",
            "in": "query",
            "name": "jobId",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for bulk load result deletion complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of bulk load result deletion",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to access bulk file results",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Delete results from the bulk file load table of the dataset. If jobId is specified, then only the results for the loadTag plus that jobId are deleted. Otherwise, all results associated with the loadTag are deleted.",
        "operationId": "bulkFileResultsDelete"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "a load tag",
            "in": "path",
            "name": "loadTag",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for bulk load result retrieval complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/BulkLoadHistoryModelList"
            }
          },
          "202": {
            "description": "Job status of bulk load result retrieval",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to access bulk file results",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve the results of a bulk file load. The results of each bulk load are stored in the dataset. They can be queried directly or retrieved with this paginated interface.",
        "operationId": "getLoadHistoryForLoadTag"
      }
    },
    "/api/repository/v1/datasets/{id}/files/{fileid}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A file id",
            "in": "path",
            "name": "fileid",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for snapshot successful creation",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of snapshot creation job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to delete file",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id or file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Hard delete of a file by id. The file is deleted even if it is in use by a dataset. Subsequent lookups will give not found errors.\n",
        "operationId": "deleteFile"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A file id",
            "in": "path",
            "name": "fileid",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "Enumeration depth; -1 means fully expand; 0 means no expansion; 1..N expands that many subdirectories",
            "in": "query",
            "name": "depth",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "File exists",
            "schema": {
              "$ref": "#/definitions/FileModel"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Lookup metadata for one file",
        "operationId": "lookupFileById"
      }
    },
    "/api/repository/v1/datasets/{id}/filesystem/objects": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "URL-encoded full path to a file or directory",
            "in": "query",
            "name": "path",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "Enumeration depth; -1 means fully expand; 0 means no expansion; 1..N expands that many subdirectories",
            "in": "query",
            "name": "depth",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "File exists",
            "schema": {
              "$ref": "#/definitions/FileModel"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Lookup metadata for one file",
        "operationId": "lookupFileByPath"
      }
    },
    "/api/repository/v1/datasets/{id}/ingest": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Ingest request",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/IngestRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for ingest complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of ingest job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid ingest request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to ingest",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Ingest data into a dataset table",
        "operationId": "ingestDataset",
        "x-codegen-request-body-name": "ingest"
      }
    },
    "/api/repository/v1/datasets/{id}/lock": {
      "put": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Lock successful. ResourceLocks object is returned with the locking job id as the exclusive lock value, showing that there is an exclusive lock this resource.\n",
            "schema": {
              "$ref": "#/definitions/ResourceLocks"
            }
          },
          "400": {
            "description": "Bad request - malformed dataset Id.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - dataset does not exist or the caller is missing permissions to lock the dataset.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - a dataset with the specified Id does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - dataset was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Add an exclusive lock to the dataset so that no update or delete operations can be performed on it.\n",
        "operationId": "lockDataset"
      }
    },
    "/api/repository/v1/datasets/{id}/policies": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Policy",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve the read and discover policies for the dataset",
        "operationId": "retrieveDatasetPolicies"
      }
    },
    "/api/repository/v1/datasets/{id}/policies/{policyName}/members": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "steward",
              "custodian",
              "snapshot_creator"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "description": "Dataset to change the policy of",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/PolicyMemberRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "PolicyResponse",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed, or email not found",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Adds a member to the specified policy for the dataset",
        "operationId": "addDatasetPolicyMember",
        "x-codegen-request-body-name": "policyMember"
      }
    },
    "/api/repository/v1/datasets/{id}/policies/{policyName}/members/{memberEmail}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "steward",
              "custodian",
              "snapshot_creator"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "description": "The email of the user to remove",
            "in": "path",
            "name": "memberEmail",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "PolicyResponse",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Removes the member from the specified policy for the dataset",
        "operationId": "deleteDatasetPolicyMember"
      }
    },
    "/api/repository/v1/datasets/{id}/roles": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Policy",
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve the policies the calling user has on the dataset",
        "operationId": "retrieveUserDatasetRoles"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotBuilder/conceptHierarchy/{conceptId}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the dataset.",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A dataset concept id.",
            "in": "path",
            "name": "conceptId",
            "required": true,
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "The concepts that define the hierarchy that contain this concept.",
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderGetConceptHierarchyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to view snapshot builder settings.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Given a concept ID, return the tree of concepts that contain this concept. A tree is represented as a list of parent IDs and their children, which are concepts.\n",
        "operationId": "getConceptHierarchy"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotBuilder/concepts/{conceptId}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the dataset.",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A dataset concept id.",
            "in": "path",
            "name": "conceptId",
            "required": true,
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "The concepts with the specified concept as their parent",
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderGetConceptsResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to view snapshot builder settings.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Gets all concepts with the specified concept as their parent.\n",
        "operationId": "getConcepts"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotBuilder/concepts/{domainId}/search": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the dataset.",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The concept ID of the domain",
            "in": "path",
            "name": "domainId",
            "required": true,
            "type": "integer"
          },
          {
            "description": "User specified text to search concepts for.",
            "in": "query",
            "name": "searchText",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The concepts of the specified domain that match the given text.",
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderGetConceptsResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to update snapshot builder settings.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset or domain found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Searches concepts of the specified domain that match the given searchText.\n",
        "operationId": "searchConcepts"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotBuilder/count": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the dataset.",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The cohorts to count participants in",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderCountRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The concepts with the specified concept as their parent",
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderCountResponse"
            }
          },
          "401": {
            "description": "Unauthorized - missing permissions to compute count.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to compute count.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Given a list of snapshot builder cohorts, return the unique participant count for this dataset.\n",
        "operationId": "getSnapshotBuilderCount"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotBuilder/settings": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the dataset.",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "New settings for the dataset to use for snapshot building",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SnapshotBuilderSettings"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The updated Dataset",
            "schema": {
              "$ref": "#/definitions/DatasetModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to update snapshot builder settings.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Updates the settings for using the dataset in the snapshot builder.\n",
        "operationId": "updateDatasetSnapshotBuilderSettings"
      }
    },
    "/api/repository/v1/datasets/{id}/snapshotRequests": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The snapshot requests have been retrieved.",
            "schema": {
              "$ref": "#/definitions/EnumerateSnapshotAccessRequest"
            }
          },
          "400": {
            "description": "Bad request - invalid id, or badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to view snapshot requests.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameter.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets"
        ],
        "description": "As an admin for this dataset, view all snapshot requests for this dataset.",
        "operationId": "enumerateSnapshotRequests"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Description of the snapshot being requested.",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/SnapshotAccessRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has been made.",
            "schema": {
              "$ref": "#/definitions/SnapshotAccessRequestResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, snapshotRequest, or badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - dataset does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - missing permissions to request snapshot.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No dataset found that meets the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets"
        ],
        "description": "As a researcher, create a snapshot request for a dataset, given a set of criteria and required concept sets and values.",
        "operationId": "createSnapshotRequest"
      }
    },
    "/api/repository/v1/datasets/{id}/summary": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset summary",
            "schema": {
              "$ref": "#/definitions/DatasetSummaryModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see dataset summary",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve a dataset summary by id.  If the caller has permission to list the dataset in an enumeration, they will have permission to retrieve its summary, whereas they may lack necessary permissions to retrieve the full dataset object.\n",
        "operationId": "retrieveDatasetSummary"
      }
    },
    "/api/repository/v1/datasets/{id}/tags": {
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/TagUpdateRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Dataset summary with updated tags",
            "schema": {
              "$ref": "#/definitions/DatasetSummaryModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - dataset does not exist or the caller is missing permissions to modify its metadata.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - dataset was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Update tags on dataset",
        "operationId": "updateDatasetTags"
      }
    },
    "/api/repository/v1/datasets/{id}/transactions": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "List of transactions",
            "schema": {
              "items": {
                "$ref": "#/definitions/TransactionModel"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad request - invalid parameters",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to list transactions",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Lists transactions on the dataset",
        "operationId": "enumerateTransactions"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Open transaction request",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/TransactionCreateModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for transaction open complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of transaction open job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid transaction creation request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to create transaction",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Create a transaction to be used for ingesting if you are chaining ingests together",
        "operationId": "openTransaction",
        "x-codegen-request-body-name": "transaction"
      }
    },
    "/api/repository/v1/datasets/{id}/transactions/{transactionId}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A UUID to used to identify a transaction in a dataset",
            "format": "uuid",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Information on a given transaction header",
            "schema": {
              "$ref": "#/definitions/TransactionModel"
            }
          },
          "400": {
            "description": "Bad request - invalid query pameters",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to read transaction from this datasset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id or transaction id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Retrieve a given transaction",
        "operationId": "retrieveTransaction"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A UUID to used to identify a transaction in a dataset",
            "format": "uuid",
            "in": "path",
            "name": "transactionId",
            "required": true,
            "type": "string"
          },
          {
            "description": "Close transaction request",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/TransactionCloseModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for transaction terminate complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of transaction commit job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid transaction terminat request, badly formed or unrecognized state",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to terminate the transaction for this datasset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id or transaction id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Close a given transaction",
        "operationId": "closeTransaction"
      }
    },
    "/api/repository/v1/datasets/{id}/unlock": {
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/UnlockResourceRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Unlock successful. ResourceLocks object is returned with a \"null\" value if there are no locks on the resource.\n",
            "schema": {
              "$ref": "#/definitions/ResourceLocks"
            }
          },
          "400": {
            "description": "Bad request - malformed dataset Id.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - dataset does not exist or the caller is missing permissions to unlock the dataset.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - a dataset with the specified Id does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Conflict - the dataset is not locked or the provided lock name is not the locking flight id.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - dataset was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Remove an exclusive or shared lock on the dataset.\n",
        "operationId": "unlockDataset"
      }
    },
    "/api/repository/v1/datasets/{id}/updateSchema": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Update dataset schema",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DatasetSchemaUpdateModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for schema update complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of schema update job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid schema update request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update schema",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - dataset id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "datasets",
          "repository"
        ],
        "description": "Modify a dataset's schema with additive changes",
        "operationId": "updateSchema"
      }
    },
    "/api/repository/v1/duos": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "List of DUOS Firecloud groups",
            "schema": {
              "items": {
                "$ref": "#/definitions/DuosFirecloudGroupModel"
              },
              "type": "array"
            }
          },
          "500": {
            "description": "An unexpected error occurred.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "duos",
          "repository"
        ],
        "description": "Returns a list of all DUOS Firecloud groups managed by TDR. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "retrieveDuosFirecloudGroups"
      }
    },
    "/api/repository/v1/duos/syncAuthorizedUsers": {
      "put": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Sync complete - see contents to gauge overall success.",
            "schema": {
              "$ref": "#/definitions/DuosFirecloudGroupsSyncResponse"
            }
          },
          "403": {
            "description": "Unauthorized - the caller must be a TDR Admin or TDR-DUOS Integration Admin to facilitate sync.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - Firecloud group contents may not have been updated.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "duos",
          "repository"
        ],
        "description": "Sync the members of all TDR-managed DUOS Firecloud groups with the authorized users of their corresponding DUOS datasets.  Any snapshots linked to a DUOS dataset have its Firecloud group as a reader, which means its members are also snapshot readers. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "syncDuosDatasetsAuthorizedUsers"
      }
    },
    "/api/repository/v1/duos/{duosId}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "DUOS dataset identifier",
            "in": "path",
            "name": "duosId",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "DUOS Firecloud group",
            "schema": {
              "$ref": "#/definitions/DuosFirecloudGroupModel"
            }
          },
          "404": {
            "description": "Not found - TDR has no record of of a DUOS dataset with the specified ID.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "duos",
          "repository"
        ],
        "description": "Returns a DUOS Firecloud group managed by TDR. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "retrieveDuosFirecloudGroup"
      }
    },
    "/api/repository/v1/duos/{duosId}/syncAuthorizedUsers": {
      "put": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "DUOS dataset identifier",
            "in": "path",
            "name": "duosId",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Firecloud group contents successfully updated.",
            "schema": {
              "$ref": "#/definitions/DuosFirecloudGroupModel"
            }
          },
          "403": {
            "description": "Unauthorized - the caller must be a TDR Admin or TDR-DUOS Integration Admin to facilitate sync.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - TDR has no record of of a DUOS dataset with the specified ID.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Conflict - Firecloud group contents may have been updated, but TDR encountered a conflict when writing back to the database.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - Firecloud group contents may not have been updated.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "duos",
          "repository"
        ],
        "description": "Sync the DUOS dataset's authorized users as members of their corresponding TDR-managed Firecloud group.  Any snapshots linked to the DUOS dataset have this Firecloud group as a reader, which means its members are also snapshot readers. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "syncDuosDatasetAuthorizedUsers"
      }
    },
    "/api/repository/v1/jobs": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          },
          {
            "default": "desc",
            "description": "The direction to sort based on job creation time (default is descending).",
            "enum": [
              "asc",
              "desc"
            ],
            "in": "query",
            "name": "direction",
            "type": "string"
          },
          {
            "description": "Filter by the flight's class",
            "in": "query",
            "name": "className",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "List of jobs",
            "schema": {
              "items": {
                "$ref": "#/definitions/JobModel"
              },
              "type": "array"
            }
          }
        },
        "tags": [
          "jobs",
          "repository"
        ],
        "description": "Returns a list of all recently submitted jobs that the caller has access to\n",
        "operationId": "enumerateJobs"
      }
    },
    "/api/repository/v1/jobs/{id}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for object successful creation",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see job",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - job id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "jobs",
          "repository"
        ],
        "description": "Retrieve a job's status by id",
        "operationId": "retrieveJob"
      }
    },
    "/api/repository/v1/jobs/{id}/result": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "202": {
            "description": "The job is currently running",
            "schema": {
              "type": "object"
            }
          },
          "default": {
            "description": "Successful responses return the type of model specified by the job; otherwise, ErrorModel",
            "schema": {
              "type": "object"
            }
          }
        },
        "tags": [
          "jobs",
          "repository"
        ],
        "description": "Retrieve a job's result by id",
        "operationId": "retrieveJobResult"
      }
    },
    "/api/repository/v1/journal/{resourceKey}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "The UUID of the journaled resource.",
            "format": "uuid",
            "in": "path",
            "name": "resourceKey",
            "required": true,
            "type": "string"
          },
          {
            "description": "The IamResource type of the journaled resource.",
            "enum": [
              "DATASET",
              "DATASNAPSHOT",
              "SPEND_PROFILE",
              "DATAREPO",
              "WORKSPACE"
            ],
            "in": "query",
            "name": "resourceType",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of entries to skip before when retrieving the next page",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The number of entries to retrieve and return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "List of journal entries",
            "schema": {
              "items": {
                "$ref": "#/definitions/JournalEntryModel"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed IamResourceType.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - journal entry does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - journal entry does not exist or missing permissions to view.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "No journal entries found that meet the request parameters.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "journal"
        ],
        "description": "Returns a list of journal entries for an object the caller has access to, in descending order of entry creation.\n",
        "operationId": "retrieveJournalEntries"
      }
    },
    "/api/repository/v1/register/user": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "User Info",
            "schema": {
              "$ref": "#/definitions/UserStatusInfo"
            }
          }
        },
        "tags": [
          "register",
          "repository"
        ],
        "description": "Returns whether the user is registered with terra\n",
        "operationId": "user"
      }
    },
    "/api/repository/v1/snapshots": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          },
          {
            "default": "created_date",
            "description": "The field to use for sorting.",
            "enum": [
              "name",
              "description",
              "created_date"
            ],
            "in": "query",
            "name": "sort",
            "type": "string"
          },
          {
            "default": "asc",
            "description": "The direction to sort.",
            "enum": [
              "asc",
              "desc"
            ],
            "in": "query",
            "name": "direction",
            "type": "string"
          },
          {
            "description": "Filter the results where this string is a case insensitive match in the name or description.",
            "in": "query",
            "name": "filter",
            "type": "string"
          },
          {
            "description": "Filter the results where this string is a case insensitive match in any of the cloud storage regions used by the source datasets.",
            "in": "query",
            "name": "region",
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter the results where these datasetIds are source datasets.",
            "in": "query",
            "items": {
              "type": "string"
            },
            "name": "datasetIds",
            "required": false,
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter the results where these case sensitive tags are applied to the snapshots\n",
            "in": "query",
            "items": {
              "$ref": "#/definitions/Tag"
            },
            "name": "tags",
            "required": false,
            "type": "array"
          },
          {
            "collectionFormat": "multi",
            "description": "Filter the results where snapshots have been linked to one of these DUOS datasetIds\n",
            "in": "query",
            "items": {
              "$ref": "#/definitions/DuosId"
            },
            "name": "duosDatasetIds",
            "required": false,
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "List of snapshots",
            "schema": {
              "$ref": "#/definitions/EnumerateSnapshotModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Returns a list of all of the snapshots to which the caller has access. Access may be granted directly via SAM and/or indirectly via a user's linked RAS passport in Terra.  Snapshot accessibility derived from a linked RAS passport will be attributed to the \"reader\" role.\n",
        "operationId": "enumerateSnapshots"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Snapshot to create",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/SnapshotRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for snapshot successful creation",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of snapshot creation job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid name, badly formed or user email not found",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to create snapshots",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Snapshot with this name already exists",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Create a new snapshot",
        "operationId": "createSnapshot",
        "x-codegen-request-body-name": "snapshot"
      }
    },
    "/api/repository/v1/snapshots/roleMap": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Accessible snapshot IDs and roles",
            "schema": {
              "$ref": "#/definitions/SnapshotIdsAndRolesModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Get accessible snapshot IDs mapped to the roles which confer access. Access may be granted directly via Sam and/or indirectly via a user's linked RAS passport in Terra.  Snapshot accessibility derived from a linked RAS passport will be attributed to the \"reader\" role.\n",
        "operationId": "getSnapshotIdsAndRoles"
      }
    },
    "/api/repository/v1/snapshots/tags": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "Filter to tags with this string as a case-insensitive match.",
            "in": "query",
            "name": "filter",
            "type": "string"
          },
          {
            "description": "The maximum number of tags to return, in descending order of occurrence count. All accessible tags will be returned if unspecified.\n",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "Accessible snapshot tags matching specified filters.",
            "schema": {
              "$ref": "#/definitions/TagCountResultModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Get accessible snapshot tags. Access may be granted directly via Sam and/or indirectly via a user's linked RAS passport in Terra.\n",
        "operationId": "getSnapshotTags"
      }
    },
    "/api/repository/v1/snapshots/{id}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for snapshot successful deletion",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of snapshot deletion job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to delete snapshot",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Snapshot in use?",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Delete a snapshot by id",
        "operationId": "deleteSnapshot"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "collectionFormat": "multi",
            "default": "SOURCES,TABLES,RELATIONSHIPS,PROFILE,DATA_PROJECT,DUOS",
            "description": "A list of what to include with the snapshot object",
            "in": "query",
            "items": {
              "$ref": "#/definitions/SnapshotRetrieveIncludeModel"
            },
            "name": "include",
            "required": false,
            "type": "array"
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot",
            "schema": {
              "$ref": "#/definitions/SnapshotModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see snapshot",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Retrieve a snapshot by id",
        "operationId": "retrieveSnapshot"
      },
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A 'lite' snapshot definition (used to modify supported fields of a snapshot). Null assignments will be ignored.",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/SnapshotPatchRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Summary of updated snapshot.",
            "schema": {
              "$ref": "#/definitions/SnapshotSummaryModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed modification instructions.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "Unauthorized - snapshot does not exist, missing permissions to modify.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Update supported fields of the specified snapshot.",
        "operationId": "patchSnapshot"
      }
    },
    "/api/repository/v1/snapshots/{id}/authDomain": {
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "items": {
                "description": "A list of Sam user group names",
                "type": "string"
              },
              "type": "array"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The snapshot's data access control groups",
            "schema": {
              "$ref": "#/definitions/AddAuthDomainResponseModel"
            }
          },
          "400": {
            "description": "Bad request - badly formed request body",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to add data access control groups to this snapshot",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred, or the Sam group was not found.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Add data access control groups to the snapshot.  The provided user groups will be registered as a group constraint policy in Terra Policy Service, and as an auth domain in Sam.\n\n*** WARNING - Once this is set it cannot be modified ***\n\nIf a snapshot has data access controls, a user must have access to the resource directly (via a policy) and belong to all of its data access control groups in order to view and export the data. For example, if a user is a steward of a snapshot but is not a member of its data access control groups, Sam will prevent that user from accessing the resource.\n",
        "operationId": "addSnapshotAuthDomain"
      }
    },
    "/api/repository/v1/snapshots/{id}/data/{table}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table to get data from",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of rows to skip when retrieving the next page",
            "in": "query",
            "minimum": 0,
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 30,
            "description": "The number of rows to return for the data",
            "in": "query",
            "maximum": 1000,
            "minimum": 1,
            "name": "limit",
            "type": "integer"
          },
          {
            "default": "datarepo_row_id",
            "description": "The table column to sort by",
            "in": "query",
            "name": "sort",
            "type": "string"
          },
          {
            "default": "asc",
            "description": "The direction to sort.",
            "enum": [
              "asc",
              "desc"
            ],
            "in": "query",
            "name": "direction",
            "type": "string"
          },
          {
            "description": "A SQL WHERE clause to filter the table results.",
            "in": "query",
            "name": "filter",
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the table data from a snapshot",
            "schema": {
              "$ref": "#/definitions/SnapshotPreviewModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "search",
          "repository"
        ],
        "deprecated": true,
        "description": "Retrieve data for a table in a snapshot. This endpoint is deprecated, please use the POST version.",
        "operationId": "lookupSnapshotPreviewById"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "Name of table to get data from",
            "in": "path",
            "name": "table",
            "required": true,
            "type": "string"
          },
          {
            "description": "Parameters to filter results",
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/QueryDataRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the table data from a snapshot",
            "schema": {
              "$ref": "#/definitions/SnapshotPreviewModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "search",
          "repository"
        ],
        "description": "Retrieve data for a table in a snapshot.",
        "operationId": "querySnapshotDataById"
      }
    },
    "/api/repository/v1/snapshots/{id}/export": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "default": false,
            "description": "Convert DRS urls to GS paths in the output parquet file. Note, GS paths could change over time.",
            "in": "query",
            "name": "exportGsPaths",
            "type": "boolean"
          },
          {
            "default": true,
            "description": "Verify that primary keys are unique in all exported tables. Required for proper Terra workspace integration",
            "in": "query",
            "name": "validatePrimaryKeyUniqueness",
            "type": "boolean"
          },
          {
            "default": true,
            "description": "If true, then the export will generate signed URLs for the exported files and manifest. If false, then the export will return URLs native to the cloud backing the snapshot.  Note that this has no effect on Azure backed snapshots",
            "in": "query",
            "name": "signUrls",
            "type": "boolean"
          }
        ],
        "responses": {
          "202": {
            "description": "Job status of snapshot export job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to export snapshot",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Export a snapshot by id",
        "operationId": "exportSnapshot"
      }
    },
    "/api/repository/v1/snapshots/{id}/files": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "List of files",
            "schema": {
              "items": {
                "$ref": "#/definitions/FileModel"
              },
              "type": "array"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "List metadata for all files in a snapshot.",
        "operationId": "listFiles"
      }
    },
    "/api/repository/v1/snapshots/{id}/files/{fileid}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "A file id",
            "in": "path",
            "name": "fileid",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "Enumeration depth; -1 means fully expand; 0 means no expansion; 1..N expands that many subdirectories",
            "in": "query",
            "name": "depth",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "File exists",
            "schema": {
              "$ref": "#/definitions/FileModel"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Lookup metadata for one file",
        "operationId": "lookupSnapshotFileById"
      }
    },
    "/api/repository/v1/snapshots/{id}/filesystem/objects": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "URL-encoded full path to a file or directory",
            "in": "query",
            "name": "path",
            "required": true,
            "type": "string"
          },
          {
            "default": 0,
            "description": "Enumeration depth; -1 means fully expand; 0 means no expansion; 1..N expands that many subdirectories",
            "in": "query",
            "name": "depth",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "File exists",
            "schema": {
              "$ref": "#/definitions/FileModel"
            }
          },
          "400": {
            "description": "Bad request - not sure this will ever happen",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - file id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "No idea if we will generate this error code",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Lookup metadata for one file",
        "operationId": "lookupSnapshotFileByPath"
      }
    },
    "/api/repository/v1/snapshots/{id}/linkDuosDataset/{duosId}": {
      "put": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "DUOS dataset identifier",
            "in": "path",
            "name": "duosId",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The DUOS Firecloud group made a snapshot reader, and any previously linked DUOS Firecloud group removed as a snapshot reader.\n",
            "schema": {
              "$ref": "#/definitions/SnapshotLinkDuosDatasetResponse"
            }
          },
          "400": {
            "description": "Bad request - malformed snapshot ID or DUOS dataset ID.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - snapshot does not exist or the caller is missing permissions to link it to a DUOS dataset.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - a DUOS dataset with the specified ID does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Link the DUOS dataset to the snapshot so that its authorized users are synced as snapshot readers. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "linkDuosDatasetToSnapshot"
      }
    },
    "/api/repository/v1/snapshots/{id}/lock": {
      "put": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Lock successful. ResourceLocks object is returned with the locking job id as the exclusive lock value, showing that there is an exclusive lock this resource.\n",
            "schema": {
              "$ref": "#/definitions/ResourceLocks"
            }
          },
          "400": {
            "description": "Bad request - malformed snapshot Id.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - the snapshot does not exist or the caller is missing permissions to lock the snapshot.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - a snapshot with the specified Id does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Add an exclusive lock to the snapshot so that no delete operations can be performed on it.\n",
        "operationId": "lockSnapshot"
      }
    },
    "/api/repository/v1/snapshots/{id}/policies": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Policy",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Retrieve the read and discover policies for the snapshot",
        "operationId": "retrieveSnapshotPolicies"
      }
    },
    "/api/repository/v1/snapshots/{id}/policies/{policyName}/members": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "steward",
              "reader",
              "discoverer"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "description": "Snapshot to change the policy of",
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/PolicyMemberRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "PolicyResponse",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed, or email not found",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Adds a member to the specified policy for the snapshot",
        "operationId": "addSnapshotPolicyMember",
        "x-codegen-request-body-name": "policyMember"
      }
    },
    "/api/repository/v1/snapshots/{id}/policies/{policyName}/members/{memberEmail}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "steward",
              "reader",
              "discoverer"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "description": "The email of the user to remove",
            "in": "path",
            "name": "memberEmail",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "PolicyResponse",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Removes a member from the specified policy for the snapshot",
        "operationId": "deleteSnapshotPolicyMember"
      }
    },
    "/api/repository/v1/snapshots/{id}/roles": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Policy",
            "schema": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Retrieve the roles the calling user has on the snapshot",
        "operationId": "retrieveUserSnapshotRoles"
      }
    },
    "/api/repository/v1/snapshots/{id}/summary": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot summary",
            "schema": {
              "$ref": "#/definitions/SnapshotSummaryModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see snapshot summary",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Retrieve a snapshot summary by id.  If the caller has permission to list the snapshot in an enumeration, they will have permission to retrieve its summary, whereas they may lack necessary permissions to retrieve the full snapshot object.\n",
        "operationId": "retrieveSnapshotSummary"
      }
    },
    "/api/repository/v1/snapshots/{id}/tags": {
      "patch": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "schema": {
              "$ref": "#/definitions/TagUpdateRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Snapshot summary with updated tags",
            "schema": {
              "$ref": "#/definitions/SnapshotSummaryModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - snapshot does not exist or the caller is missing permissions to modify its metadata.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Update tags on snapshot",
        "operationId": "updateSnapshotTags"
      }
    },
    "/api/repository/v1/snapshots/{id}/unlinkDuosDataset": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Any previously linked DUOS Firecloud group removed as a snapshot reader.\n",
            "schema": {
              "$ref": "#/definitions/SnapshotLinkDuosDatasetResponse"
            }
          },
          "400": {
            "description": "Bad request - malformed snapshot ID.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - snapshot does not exist or the caller is missing permissions to unlink its DUOS dataset.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Unlink the DUOS dataset from the snapshot so that its authorized users are no longer synced as snapshot readers. NOTE: This is an experimental feature and its response body may change.\n",
        "operationId": "unlinkDuosDatasetFromSnapshot"
      }
    },
    "/api/repository/v1/snapshots/{id}/unlock": {
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UnlockResourceRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Unlock successful. ResourceLocks object is returned with a \"null\" value showing that there is no longer an exclusive lock on this resource.\n",
            "schema": {
              "$ref": "#/definitions/ResourceLocks"
            }
          },
          "400": {
            "description": "Bad request - malformed snapshot Id or lock name.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "Unauthorized - snapshot does not exist or the caller is missing permissions to unlock the snapshot.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - a snapshot with the specified Id does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Conflict - the snapshot is not locked or the provided lock name is not the locking flight id.\n",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "500": {
            "description": "An unexpected error occurred - snapshot was not updated.",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "snapshots",
          "repository"
        ],
        "description": "Remove an exclusive lock on the snapshot.\n",
        "operationId": "unlockSnapshot"
      }
    },
    "/api/repository/v1/upgrade": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpgradeModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for upgrade complete",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of upgrade job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid upgrade request, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to upgrade",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "upgrade",
          "repository"
        ],
        "description": "Extensible endpoint for triggering upgrade tasks in the data repository. The asynchronous result is UpgradeResponseModel",
        "operationId": "upgrade",
        "x-codegen-request-body-name": "upgrade"
      }
    },
    "/api/resources/v1/profiles": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "default": 0,
            "description": "The number of items to skip before starting to collect the result set.",
            "in": "query",
            "name": "offset",
            "type": "integer"
          },
          {
            "default": 10,
            "description": "The numbers of items to return.",
            "in": "query",
            "name": "limit",
            "type": "integer"
          }
        ],
        "responses": {
          "200": {
            "description": "List of billing profiles",
            "schema": {
              "$ref": "#/definitions/EnumerateBillingProfileModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Returns a list of all of the billing profiles\n",
        "operationId": "enumerateProfiles"
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": false,
            "schema": {
              "$ref": "#/definitions/BillingProfileRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for profile successful creation",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of profile creation job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - see error message",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to create profiles",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Creates a new profile associated with a billing account. This is asynchronous. The final return is of type definitions/BillingProfileModel.\n",
        "operationId": "createProfile",
        "x-codegen-request-body-name": "billingProfileRequest"
      },
      "put": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/BillingProfileUpdateModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for profile update result",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of profile update job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update profile",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - profile does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Update a billing profile by id. This is asynchronous. The final return is of type definitions/BillingProfileModel.\n",
        "operationId": "updateProfile"
      }
    },
    "/api/resources/v1/profiles/{id}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "default": false,
            "description": "ADMIN ONLY - Delete all Azure cloud resources along with billing profile.",
            "in": "query",
            "name": "deleteCloudResources",
            "required": false,
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "Redirect for profile delete result",
            "headers": {
              "location": {
                "description": "url for the job result",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "202": {
            "description": "Job status of profile delete job & url for polling in the response header",
            "headers": {
              "location": {
                "description": "url for the job polling",
                "type": "string"
              }
            },
            "schema": {
              "$ref": "#/definitions/JobModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to delete profile",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - profile does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "409": {
            "description": "Profile in use by at least one dataset",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Delete a billing profile by id. This is asynchronous. The final return is of type definitions/DeleteResponseModel.\n",
        "operationId": "deleteProfile"
      },
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Billing profile",
            "schema": {
              "$ref": "#/definitions/BillingProfileModel"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see billing profile",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - billing profile id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Retrieve a billing profile by id",
        "operationId": "retrieveProfile"
      }
    },
    "/api/resources/v1/profiles/{id}/policies": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "Policy",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to see policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Retrieve the read and discover policies for the profile",
        "operationId": "retrieveProfilePolicies"
      }
    },
    "/api/resources/v1/profiles/{id}/policies/{policyName}/members": {
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "owner",
              "user"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/PolicyMemberRequest"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Policy",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed, or email not found",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - profile id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Adds a member to the specified policy for the profile.\nNOTE: Change may take up to 60 seconds to take effect.\n",
        "operationId": "addProfilePolicyMember"
      }
    },
    "/api/resources/v1/profiles/{id}/policies/{policyName}/members/{memberEmail}": {
      "delete": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "A UUID to used to identify an object in the repository",
            "format": "uuid",
            "in": "path",
            "name": "id",
            "required": true,
            "type": "string"
          },
          {
            "description": "The relevant policy",
            "enum": [
              "owner",
              "user"
            ],
            "in": "path",
            "name": "policyName",
            "required": true,
            "type": "string"
          },
          {
            "description": "The email of the user to remove",
            "in": "path",
            "name": "memberEmail",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "PolicyResponse",
            "schema": {
              "$ref": "#/definitions/PolicyResponse"
            }
          },
          "400": {
            "description": "Bad request - invalid id, badly formed",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "403": {
            "description": "No permission to update policies",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          },
          "404": {
            "description": "Not found - snapshot id does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorModel"
            }
          }
        },
        "tags": [
          "profiles",
          "resources"
        ],
        "description": "Removes a member from the specified policy for the profile.\nNOTE: Change may take up to 60 seconds to take effect.\n",
        "operationId": "deleteProfilePolicyMember"
      }
    },
    "/configuration": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Repository Config",
            "schema": {
              "$ref": "#/definitions/RepositoryConfigurationModel"
            }
          },
          "500": {
            "description": "Config is unavailable"
          }
        },
        "tags": [
          "unauthenticated"
        ],
        "description": "Retrieve the repository configuration information",
        "operationId": "retrieveRepositoryConfig"
      }
    },
    "/ga4gh/drs/v1/objects/{object_id}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "object_id",
            "required": true,
            "type": "string"
          },
          {
            "default": false,
            "description": "If false and the object_id refers to a bundle, then the ContentsObject array contains only those objects directly contained in the bundle. That is, if the bundle contains other bundles, those other bundles are not recursively included in the result. If true and the object_id refers to a bundle, then the entire set of objects in the bundle is expanded. That is, if the bundle contains another bundles, then those other bundles are recursively expanded and included in the result. Recursion continues through the entire sub-tree of the bundle. If the object_id refers to a blob, then the query parameter is ignored.",
            "in": "query",
            "name": "expand",
            "type": "boolean"
          }
        ],
        "responses": {
          "200": {
            "description": "The `Object` was found successfully.",
            "schema": {
              "$ref": "#/definitions/DRSObject"
            }
          },
          "202": {
            "description": "The operation is delayed and will continue asynchronously. The client should retry this same request after the delay specified by Retry-After header.\n",
            "headers": {
              "Retry-After": {
                "description": "Delay in seconds. The client should retry this same request after waiting for this duration. To simplify client response processing, this must be an integral relative time in seconds. This value SHOULD represent the minimum duration the client should wait before attempting the operation again with a reasonable expectation of success. When it is not feasible for the server to determine the actual expected delay, the server may return a brief, fixed value instead.\n",
                "format": "int64",
                "type": "integer"
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "403": {
            "description": "The requester is not authorized to perform this action.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "404": {
            "description": "The requested `Object` wasn't found",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "Returns object metadata, and a list of access methods that can be used to fetch object bytes.\nNOTE: Changes to the object's dataset or snapshot may take up to 15 minutes to be reflected in this response.\n",
        "operationId": "GetObject",
        "summary": "Get info about an `Object`."
      },
      "options": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "object_id",
            "required": true,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "`DRSAuthorizations` were found successfully",
            "schema": {
              "$ref": "#/definitions/DRSAuthorizations"
            }
          },
          "204": {
            "description": "`DRSAuthorizations` are not supported for this object. Default to `None`."
          },
          "400": {
            "description": "The request is malformed.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "404": {
            "description": "The requested `Object` wasn't found",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "405": {
            "description": "`DRSAuthorizations` are not supported for this object. Default to `None`."
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "Returns `DRSAuthorizations` that can be used to determine how to authorize requests to GET or POST a `DRSObject`.\nNOTE: Changes to the object's dataset or snapshot may take up to 15 minutes to be reflected in this response.\n",
        "operationId": "OptionsObject",
        "summary": "Get Authorization info about a DRS Object."
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "in": "path",
            "name": "object_id",
            "required": true,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DRSPassportRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The `Object` was found successfully.",
            "schema": {
              "$ref": "#/definitions/DRSObject"
            }
          },
          "202": {
            "description": "The operation is delayed and will continue asynchronously. The client should retry this same request after the delay specified by Retry-After header.\n",
            "headers": {
              "Retry-After": {
                "description": "Delay in seconds. The client should retry this same request after waiting for this duration. To simplify client response processing, this must be an integral relative time in seconds. This value SHOULD represent the minimum duration the client should wait before attempting the operation again with a reasonable expectation of success. When it is not feasible for the server to determine the actual expected delay, the server may return a brief, fixed value instead.\n",
                "format": "int64",
                "type": "integer"
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "403": {
            "description": "The requester is not authorized to perform this action.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "404": {
            "description": "The requested `Object` wasn't found",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "Returns object metadata, and a list of access methods that can be used to fetch object bytes. Method is a POST to accommodate a JWT GA4GH Passport sent in the formData in order to authorize access.\nNOTE: Changes to the object's dataset or snapshot may take up to 15 minutes to be reflected in this response.\n",
        "operationId": "PostObject",
        "summary": "Get info about a DrsObject through POST'ing a Passport."
      }
    },
    "/ga4gh/drs/v1/objects/{object_id}/access/{access_id}": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "An `id` of a Data Object",
            "in": "path",
            "name": "object_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "An `access_id` from the `access_methods` list of a Data Object",
            "in": "path",
            "name": "access_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "For GCP hosted files, this will indicate the user project to bill when accessing the signed url.  This value must be a valid Terra billing project ID that the caller has access to and only applies to GCP hosted data.\n",
            "in": "header",
            "name": "x-user-project",
            "required": false,
            "type": "string"
          }
        ],
        "responses": {
          "200": {
            "description": "The access URL was found successfully.",
            "schema": {
              "$ref": "#/definitions/DRSAccessURL"
            }
          },
          "202": {
            "description": "The operation is delayed and will continue asynchronously. The client should retry this same request after the delay specified by Retry-After header.\n",
            "headers": {
              "Retry-After": {
                "description": "Delay in seconds. The client should retry this same request after waiting for this duration. To simplify client response processing, this must be an integral relative time in seconds. This value SHOULD represent the minimum duration the client should wait before attempting the operation again with a reasonable expectation of success. When it is not feasible for the server to determine the actual expected delay, the server may return a brief, fixed value instead.\n",
                "format": "int64",
                "type": "integer"
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "403": {
            "description": "The requester is not authorized to perform this action.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "404": {
            "description": "The requested access URL wasn't found",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "Returns a URL that can be used to fetch the object bytes. This method only needs to be called when using an `AccessMethod` that contains an `access_id` (e.g., for servers that use signed URLs for fetching object bytes).\nNOTE: Changes to the object's dataset or snapshot may take up to 15 minutes to be reflected in this response.\n",
        "operationId": "GetAccessURL",
        "summary": "Get a URL for fetching bytes."
      },
      "post": {
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "description": "An `id` of a Data Object",
            "in": "path",
            "name": "object_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "An `access_id` from the `access_methods` list of a Data Object",
            "in": "path",
            "name": "access_id",
            "required": true,
            "type": "string"
          },
          {
            "description": "For GCP hosted files, this will indicate the user project to bill when accessing the signed url.  This value must be a valid Terra billing project ID that the caller has access to and only applies to GCP hosted data.\n",
            "in": "header",
            "name": "x-user-project",
            "required": false,
            "type": "string"
          },
          {
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DRSPassportRequestModel"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The access URL was found successfully.",
            "schema": {
              "$ref": "#/definitions/DRSAccessURL"
            }
          },
          "202": {
            "description": "The operation is delayed and will continue asynchronously. The client should retry this same request after the delay specified by Retry-After header.\n",
            "headers": {
              "Retry-After": {
                "description": "Delay in seconds. The client should retry this same request after waiting for this duration. To simplify client response processing, this must be an integral relative time in seconds. This value SHOULD represent the minimum duration the client should wait before attempting the operation again with a reasonable expectation of success. When it is not feasible for the server to determine the actual expected delay, the server may return a brief, fixed value instead.\n",
                "format": "int64",
                "type": "integer"
              }
            }
          },
          "400": {
            "description": "The request is malformed.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "401": {
            "description": "The request is unauthorized.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "403": {
            "description": "The requester is not authorized to perform this action.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "404": {
            "description": "The requested access URL wasn't found",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          },
          "500": {
            "description": "An unexpected error occurred.",
            "schema": {
              "$ref": "#/definitions/DRSError"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "Returns a URL that can be used to fetch the bytes of a `DrsObject`.\nThis method only needs to be called when using an `AccessMethod` that contains an `access_id` (e.g., for servers that use signed URLs for fetching object bytes).\nMethod is a POST to accommodate a JWT GA4GH Passport sent in the formData in order to authorize access.\nNOTE: Changes to the object's dataset or snapshot may take up to 15 minutes to be reflected in this response.\n",
        "operationId": "PostAccessURL",
        "summary": "Get a URL for fetching bytes through POST'ing a Passport"
      }
    },
    "/ga4gh/drs/v1/service-info": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Service information returned successfully",
            "schema": {
              "$ref": "#/definitions/DRSServiceInfo"
            }
          }
        },
        "tags": [
          "DataRepositoryService"
        ],
        "description": "May return service version and other information. [dd]NOTE: technically, this has been removed from DRS V1.0. It will be added back when there is a common service_info across ga4gh. I don't expect it to be too different, so just leaving this info call in place.",
        "operationId": "GetServiceInfo",
        "summary": "Get information about this implementation."
      }
    },
    "/shutdown": {
      "get": {
        "parameters": [],
        "responses": {
          "204": {
            "description": "DR Manager was shutdown successfully"
          }
        },
        "tags": [
          "unauthenticated"
        ],
        "description": "Requests that this instance of DR Manager shut down. In production, this must be configured to only be callable by Kubernetes.\n",
        "operationId": "shutdownRequest"
      }
    },
    "/status": {
      "get": {
        "produces": [
          "application/json"
        ],
        "parameters": [],
        "responses": {
          "200": {
            "description": "Service is functional",
            "schema": {
              "$ref": "#/definitions/RepositoryStatusModel"
            }
          },
          "500": {
            "description": "Service is broken",
            "schema": {
              "$ref": "#/definitions/RepositoryStatusModel"
            }
          }
        },
        "tags": [
          "unauthenticated"
        ],
        "description": "Returns the operational status of the service\n",
        "operationId": "serviceStatus"
      }
    }
  },
  "definitions": {
    "AccessInfoBigQueryModel": {
      "description": "General information on where snapshot or dataset tabular data lives in BigQuery\n",
      "properties": {
        "datasetId": {
          "description": "Unique ID of the BigQuery dataset where snapshot or dataset tabular data lives\n",
          "type": "string"
        },
        "datasetName": {
          "description": "Name of the BigQuery dataset where snapshot or dataset tabular data lives\n",
          "type": "string"
        },
        "link": {
          "description": "The link to access the BigQuery dataset UI in Google Cloud console\n",
          "type": "string"
        },
        "projectId": {
          "description": "Project id of the project where tabular data in BigQuery lives\n",
          "type": "string"
        },
        "tables": {
          "description": "Information on each table in the BigQuery dataset\n",
          "items": {
            "$ref": "#/definitions/AccessInfoBigQueryModelTable"
          },
          "type": "array"
        }
      },
      "required": [
        "datasetName",
        "datasetId",
        "projectId",
        "link",
        "tables"
      ],
      "type": "object"
    },
    "AccessInfoBigQueryModelTable": {
      "description": "Information on a snapshot or dataset table in a BigQuery dataset\n",
      "properties": {
        "id": {
          "description": "The unique id of the BigQuery table\n",
          "type": "string"
        },
        "link": {
          "description": "The link to access the BigQuery table UI in Google Cloud console\n",
          "type": "string"
        },
        "name": {
          "description": "The name of the BigQuery table\n",
          "type": "string"
        },
        "qualifiedName": {
          "description": "The fully qualified name of the BigQuery table\n",
          "type": "string"
        },
        "sampleQuery": {
          "description": "An example query that can be used to select data from this table\n",
          "type": "string"
        }
      },
      "required": [
        "name",
        "id",
        "sampleQuery",
        "qualifiedName"
      ],
      "type": "object"
    },
    "AccessInfoModel": {
      "description": "How to access the metadata for a snapshot or dataset\n",
      "properties": {
        "bigQuery": {
          "$ref": "#/definitions/AccessInfoBigQueryModel"
        },
        "parquet": {
          "$ref": "#/definitions/AccessInfoParquetModel"
        }
      },
      "type": "object"
    },
    "AccessInfoParquetModel": {
      "description": "General information on where snapshot or dataset tabular data lives in Azure\n",
      "properties": {
        "datasetId": {
          "description": "Unique ID of the Azure dataset where snapshot or dataset tabular data lives\n",
          "type": "string"
        },
        "datasetName": {
          "description": "Name of the Azure dataset where snapshot or dataset tabular data lives\n",
          "type": "string"
        },
        "sasToken": {
          "description": "A short lived SAS token to access all of the tabular data for this dataset\n",
          "type": "string"
        },
        "storageAccountId": {
          "description": "Project id of the project where tabular data in Azure lives\n",
          "type": "string"
        },
        "tables": {
          "description": "Information on each table in the Azure dataset\n",
          "items": {
            "$ref": "#/definitions/AccessInfoParquetModelTable"
          },
          "type": "array"
        },
        "url": {
          "description": "The link to access all of the tabular data for this dataset or snapshot\n",
          "type": "string"
        }
      },
      "required": [
        "datasetName",
        "datasetId",
        "storageAccountId",
        "url",
        "sasToken",
        "tables"
      ],
      "type": "object"
    },
    "AccessInfoParquetModelTable": {
      "description": "Information on a snapshot or dataset table in a Azure dataset\n",
      "properties": {
        "name": {
          "description": "The name of the dataset table\n",
          "type": "string"
        },
        "sasToken": {
          "description": "A short lived SAS token to access the parquet files for this table\n",
          "type": "string"
        },
        "url": {
          "description": "The link to access the container that stores parquet files for this table\n",
          "type": "string"
        }
      },
      "required": [
        "name",
        "url",
        "sasToken"
      ],
      "type": "object"
    },
    "AddAuthDomainResponseModel": {
      "properties": {
        "authDomain": {
          "items": {
            "description": "The Sam user groups that define this auth domain",
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "AssetModel": {
      "description": "One asset in the data model. The table list identifies the tables in the asset. The rootTable and rootColumn indicate which value will be used as the unique identifier. The list of relationships provides the instructions for how to connect the tables. Asset tables have to be connected in a relationship hierarchy. So there cannot be two paths to the same table from the root.",
      "properties": {
        "follow": {
          "items": {
            "$ref": "#/definitions/ObjectNameProperty"
          },
          "type": "array"
        },
        "name": {
          "minLength": 1,
          "type": "string"
        },
        "rootColumn": {
          "$ref": "#/definitions/ColumnNameProperty"
        },
        "rootTable": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "tables": {
          "items": {
            "$ref": "#/definitions/AssetTableModel"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "rootColumn",
        "rootTable",
        "tables"
      ],
      "type": "object"
    },
    "AssetTableModel": {
      "description": "Used in the asset definition to describe a table that is included in the asset. This is used to define the view of the asset table in the snapshot. Columns can be an empty array indicating that all columns should be included.\n",
      "properties": {
        "columns": {
          "items": {
            "$ref": "#/definitions/ColumnNameProperty"
          },
          "type": "array"
        },
        "name": {
          "$ref": "#/definitions/ObjectNameProperty"
        }
      },
      "required": [
        "columns",
        "name"
      ],
      "type": "object"
    },
    "BillingProfileModel": {
      "properties": {
        "applicationDeploymentName": {
          "description": "an optional name for an application deployment for Azure",
          "type": "string"
        },
        "biller": {
          "description": "either direct or the reseller of the sub-account that sends the bill (like on_spend)",
          "type": "string"
        },
        "billingAccountId": {
          "description": "unique identifier of the billing account from Google",
          "type": "string"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "createdBy": {
          "description": "Identity of the user who originally created the profile",
          "type": "string"
        },
        "createdDate": {
          "description": "Date the profile was created",
          "type": "string"
        },
        "description": {
          "description": "Free text that describes the profile",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "profileName": {
          "description": "display name to be used for the profile;",
          "type": "string"
        },
        "resourceGroupName": {
          "description": "an optional resource group name for Azure",
          "type": "string"
        },
        "subscriptionId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "tenantId": {
          "$ref": "#/definitions/UniqueIdProperty"
        }
      },
      "type": "object"
    },
    "BillingProfileRequestModel": {
      "properties": {
        "applicationDeploymentName": {
          "description": "an optional name for an application deployment for Azure",
          "type": "string"
        },
        "biller": {
          "description": "either direct or the reseller of the sub-account that sends the bill (like on_spend)",
          "type": "string"
        },
        "billingAccountId": {
          "description": "unique identifier of the billing account from Google",
          "type": "string"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "description": {
          "description": "Free text that describes the profile",
          "type": "string"
        },
        "id": {
          "description": "Deprecated: allowed for backwards compatibility. Recommendation: leave this unset for TDR to generate a universally unique identifier for your new billing profile.\n",
          "format": "uuid",
          "type": "string",
          "x-deprecated": true
        },
        "profileName": {
          "description": "display name to be used for the profile;",
          "type": "string"
        },
        "resourceGroupName": {
          "description": "an optional resource group name for Azure",
          "type": "string"
        },
        "subscriptionId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "tenantId": {
          "$ref": "#/definitions/UniqueIdProperty"
        }
      },
      "required": [
        "biller",
        "profileName"
      ],
      "type": "object"
    },
    "BillingProfileUpdateModel": {
      "properties": {
        "billingAccountId": {
          "description": "Unique identifier of the billing account from Google",
          "type": "string"
        },
        "description": {
          "description": "Free text that describes the profile",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        }
      },
      "required": [
        "id",
        "billingAccountId",
        "description"
      ],
      "type": "object"
    },
    "BulkLoadArrayRequestModel": {
      "description": "Body of a bulk file load request. This variant of a bulk load provides the set of files to be loaded in the body of the request. Both the summary of the load and the per-file details of the bulk load returned in the async response (BulkLoadArrayResponseModel) Per-file details of a bulk load are also stored into the dataset tabular data store and can be retrieved directly from there, or via the GET .../bulk/{loadTag} They can be cleaned up with the DELETE .../bulk/{loadTag}",
      "properties": {
        "bulkMode": {
          "default": false,
          "description": "If true, file ingest will be performed in bulk mode.  The tradeoff for the performance improvements are that: - the dataset will be locked exclusively - some safeguards can not be enforced during loads.  Given that, it's recommended that\n  you use a maxFailedFileLoads value of 0\n- the assumption is that file metadata must all fit into memory so configure the\n  deployment accordingly\n",
          "type": "boolean"
        },
        "loadArray": {
          "description": "Array files to load",
          "items": {
            "$ref": "#/definitions/BulkLoadFileModel"
          },
          "type": "array"
        },
        "loadTag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "maxFailedFileLoads": {
          "default": 0,
          "description": "max number of failed file loads before stopping; if -1, allow any number of errors",
          "type": "integer"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        }
      },
      "required": [
        "loadArray",
        "loadTag",
        "profileId",
        "maxFailedFileLoads"
      ],
      "type": "object"
    },
    "BulkLoadArrayResultModel": {
      "description": "Returned when the bulk file load job finishes.",
      "properties": {
        "loadFileResults": {
          "items": {
            "$ref": "#/definitions/BulkLoadFileResultModel"
          },
          "type": "array"
        },
        "loadSummary": {
          "$ref": "#/definitions/BulkLoadResultModel"
        }
      },
      "type": "object"
    },
    "BulkLoadFileModel": {
      "description": "Describes one file within a bulk file load",
      "properties": {
        "description": {
          "description": "A human readable description of the contents of the Data Object.",
          "type": "string"
        },
        "md5": {
          "$ref": "#/definitions/Md5OverrideModel"
        },
        "mimeType": {
          "description": "A string providing the mime-type of the Data Object. For example, \"application/json\".",
          "type": "string"
        },
        "sourcePath": {
          "description": "gs URL of the source file to load",
          "type": "string"
        },
        "targetPath": {
          "description": "Full path within the dataset where the file should be placed. The path must start with /.\n",
          "type": "string"
        }
      },
      "required": [
        "sourcePath",
        "targetPath"
      ],
      "type": "object"
    },
    "BulkLoadFileResultModel": {
      "description": "Describes the status result of one file within a bulk file load",
      "properties": {
        "error": {
          "description": "The error message if state is FAILED",
          "type": "string"
        },
        "fileId": {
          "description": "The fileId of the loaded file; non-null if state is SUCCEEDED",
          "type": "string"
        },
        "sourcePath": {
          "description": "gs URL of the source file to load",
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/BulkLoadFileState"
        },
        "targetPath": {
          "description": "Full path within the dataset where the file should be placed. The path must start with /.\n",
          "type": "string"
        }
      },
      "required": [
        "sourcePath",
        "targetPath"
      ],
      "type": "object"
    },
    "BulkLoadFileState": {
      "enum": [
        "succeeded",
        "failed",
        "not_tried",
        "running"
      ],
      "type": "string"
    },
    "BulkLoadHistoryModel": {
      "description": "Describes metadata about a file during a bulk load",
      "properties": {
        "checksumCRC": {
          "description": "The checksum crc of the loaded file; non-null if state is SUCCEEDED",
          "type": "string"
        },
        "checksumMD5": {
          "description": "The checksum md5 of the loaded file; non-null if state is SUCCEEDED",
          "type": "string"
        },
        "error": {
          "description": "The error message if state is FAILED",
          "type": "string"
        },
        "fileId": {
          "description": "The fileId of the loaded file; non-null if state is SUCCEEDED",
          "type": "string"
        },
        "sourcePath": {
          "description": "gs URL of the source file to load",
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/BulkLoadFileState"
        },
        "targetPath": {
          "description": "Full path within the dataset where the file should be placed. The path must start with /.\n",
          "type": "string"
        }
      },
      "required": [
        "sourcePath",
        "targetPath"
      ],
      "type": "object"
    },
    "BulkLoadHistoryModelList": {
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/BulkLoadHistoryModel"
          },
          "type": "array"
        },
        "total": {
          "description": "Total number of results",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "BulkLoadRequestModel": {
      "description": "Body of a bulk file load request. This variant of a bulk load provides the set of files to be loaded in a file containing the JSON form of a BulkLoadFileModel. A summary of the load results is returned in the async response (BulkLoadResponseModel) Per-file details of a bulk load are always stored into the dataset tabular data store and can be retrieved directly from there, or via the GET .../bulk/{loadTag} They can be cleaned up with the DELETE .../bulk/{loadTag}",
      "properties": {
        "bulkMode": {
          "default": false,
          "description": "If true, file ingest will be performed in bulk mode.  The tradeoff for the performance improvements are that: - the dataset will be locked exclusively - some safeguards can not be enforced during loads.  Given that, it's recommended that\n  you use a maxFailedFileLoads value of 0\n- the assumption is that file metadata must all fit into memory so configure the\n  deployment accordingly\n",
          "type": "boolean"
        },
        "loadControlFile": {
          "description": "gs:// path to a text file in a bucket. The file must be accessible to the DR Manager. Each line of the file is interpreted as the JSON form of one BulkLoadFileModel. For example, one line might look like\n  '{ \"sourcePath\":\"gs:/bucket/path/file\", \"targetPath\":\"/target/path/file\" }'",
          "type": "string"
        },
        "loadTag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "maxFailedFileLoads": {
          "default": 0,
          "description": "max number of failed file loads before stopping; if -1, allow any number of errors",
          "type": "integer"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        }
      },
      "required": [
        "loadControlFile",
        "loadTag",
        "profileId",
        "maxFailedFileLoads"
      ],
      "type": "object"
    },
    "BulkLoadResultModel": {
      "description": "Returned when the bulk file load job finishes.",
      "properties": {
        "failedFiles": {
          "type": "integer"
        },
        "jobId": {
          "type": "string"
        },
        "loadTag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "notTriedFiles": {
          "type": "integer"
        },
        "succeededFiles": {
          "type": "integer"
        },
        "totalFiles": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "CloudPlatform": {
      "default": "gcp",
      "description": "Cloud platforms supported by TDR.",
      "enum": [
        "gcp",
        "azure"
      ],
      "type": "string"
    },
    "ColumnModel": {
      "description": "one column of a table",
      "properties": {
        "array_of": {
          "default": false,
          "description": "if true, make this column an array of type datatype.",
          "type": "boolean"
        },
        "datatype": {
          "$ref": "#/definitions/TableDataType"
        },
        "name": {
          "$ref": "#/definitions/ColumnNameProperty"
        },
        "required": {
          "description": "if true, mark this column as required",
          "type": "boolean"
        }
      },
      "required": [
        "datatype",
        "name"
      ],
      "type": "object"
    },
    "ColumnNameProperty": {
      "description": "Column names follow this pattern. This should be used for the name of any column in the system. It enforces BigQuery naming rules except it disallows a leading underscore so we avoid collisions with any extra columns the DR adds. This is shorter than what BigQuery allows.\n",
      "maxLength": 63,
      "minLength": 1,
      "pattern": "^[a-zA-Z][_a-zA-Z0-9]*$",
      "type": "string"
    },
    "ColumnStatisticsDoubleModel": {
      "allOf": [
        {
          "$ref": "#/definitions/ColumnStatisticsModel"
        },
        {
          "properties": {
            "maxValue": {
              "format": "double",
              "type": "number"
            },
            "minValue": {
              "format": "double",
              "type": "number"
            }
          },
          "type": "object"
        }
      ]
    },
    "ColumnStatisticsIntModel": {
      "allOf": [
        {
          "$ref": "#/definitions/ColumnStatisticsModel"
        },
        {
          "properties": {
            "maxValue": {
              "type": "integer"
            },
            "minValue": {
              "type": "integer"
            }
          },
          "type": "object"
        }
      ]
    },
    "ColumnStatisticsModel": {
      "properties": {
        "dataType": {
          "description": "Data type of column",
          "type": "string"
        }
      },
      "required": [
        "dataType"
      ],
      "type": "object"
    },
    "ColumnStatisticsTextModel": {
      "allOf": [
        {
          "$ref": "#/definitions/ColumnStatisticsModel"
        },
        {
          "properties": {
            "values": {
              "items": {
                "$ref": "#/definitions/ColumnStatisticsTextValue"
              },
              "type": "array"
            }
          },
          "required": [
            "values"
          ],
          "type": "object"
        }
      ]
    },
    "ColumnStatisticsTextValue": {
      "properties": {
        "count": {
          "type": "integer"
        },
        "value": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "CompactIdPrefix": {
      "description": "if present, the drs URIs will be rendered using the compact id format (drs://<compactIdPrefix>:<drsId>) instead of the original format (drs://<hostname>/<drsId>).  The format is [A-Za-z0-9._] and the prefix must be registered at identifiers.org\n",
      "example": "drs.42",
      "type": "string"
    },
    "ConfigEnableModel": {
      "description": "Control whether a fault is enabled",
      "properties": {
        "enabled": {
          "default": true,
          "description": "whether to enable (default) or disable the fault",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConfigFaultCountedModel": {
      "description": "Counted fault is used to insert a fixed number of faults. A \"fault test\" is one call to the fault manager for a named fault. The skipFor lets you get the system to a certain stable point where you want to begin inserting faults. Insert gives the total number of faults to trigger. The rate gives the percentage of the time to insert the fault. A value of 50 would insert the fault half the time. A value of 20 would insert the fault 20% of the time . The rateStyle describes whether the fault will be fixed or random. In our 20 example, if the rate style is fixed, the fault would be skipped 4 times, inserted once, skipped 4 times, inserted once, etc. It uses integer math - you've been warned. If the rate style is random, a random number is generated to determine whether the fault is inserted with a probability of 0.2.\n",
      "properties": {
        "insert": {
          "description": "total number of times to insert the fault; -1 means insert forever",
          "type": "integer"
        },
        "rate": {
          "description": "insert a fault rate percent of the time. If rate is 100, the fault will always be inserted regardless of rate.\n",
          "type": "integer"
        },
        "rateStyle": {
          "description": "fixed style means insert the fault; skip for rate-1; ... random style means randomly insert the fault with probability of 1:<rate>\n",
          "enum": [
            "fixed",
            "random"
          ],
          "type": "string"
        },
        "skipFor": {
          "description": "number of fault tests to skip before beginning fault insertion",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ConfigFaultModel": {
      "description": "Fault control parameters",
      "properties": {
        "counted": {
          "$ref": "#/definitions/ConfigFaultCountedModel"
        },
        "enabled": {
          "description": "If the fault is enabled, then is in effect. Fault points cause insert faults. Typical usage is that faults are disabled on system start and explicitly enabled by test code or via the setFault endpoint.\n",
          "type": "boolean"
        },
        "faultType": {
          "description": "A simple fault has no parameters. It is just enabled or disabled. This type of fault is typically used when the desired behavior of the fault is too complex for expression in the fault types and custom code is needed to get the right failure behavior.\nA counted fault is used to insert some number of faults in a pattern. See the ConfigFaultCountedModel for details.\n",
          "enum": [
            "simple",
            "counted"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConfigGroupModel": {
      "description": "A group of ConfigModel with a label for logging",
      "properties": {
        "group": {
          "items": {
            "$ref": "#/definitions/ConfigModel"
          },
          "type": "array"
        },
        "label": {
          "description": "string to be logged with the settings to identify this set",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConfigListModel": {
      "description": "Result list of configuration settings",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/ConfigModel"
          },
          "type": "array"
        },
        "total": {
          "description": "Total number of configs",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ConfigModel": {
      "description": "There are three types of configurations: faults, parameters, and logging. Due to the way swagger works, we make a property for each type, but only the property that matches the type enumeration will be processed.\n",
      "properties": {
        "configType": {
          "enum": [
            "fault",
            "parameter",
            "logging"
          ],
          "type": "string"
        },
        "fault": {
          "$ref": "#/definitions/ConfigFaultModel"
        },
        "name": {
          "description": "name of the configuration",
          "type": "string"
        },
        "parameter": {
          "$ref": "#/definitions/ConfigParameterModel"
        }
      },
      "type": "object"
    },
    "ConfigParameterModel": {
      "description": "The value of the parameter",
      "properties": {
        "value": {
          "description": "Configuration parameters are always passed as strings and converted within the service. That keeps the JSON simple. Sending in specific types doesn't help much, because there still might be a mismatch between the type passed in and the type required.\n",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ConsentCode": {
      "description": "Consent code together with PHS ID that will determine user access",
      "type": "string"
    },
    "DRSAccessMethod": {
      "properties": {
        "access_id": {
          "description": "An arbitrary string to be passed to the `/access` path to get an `AccessURL`. This must be unique per object. Note that at least one of `access_url` and `access_id` must be provided.",
          "type": "string"
        },
        "access_url": {
          "$ref": "#/definitions/DRSAccessURL"
        },
        "authorizations": {
          "$ref": "#/definitions/DRSAuthorizations"
        },
        "region": {
          "description": "Name of the region in the cloud service provider that the object belongs to.",
          "example": "us-east-1",
          "type": "string"
        },
        "type": {
          "description": "Type of the access method.",
          "enum": [
            "s3",
            "gs",
            "ftp",
            "gsiftp",
            "globus",
            "htsget",
            "https",
            "file"
          ],
          "type": "string"
        }
      },
      "required": [
        "type"
      ],
      "type": "object"
    },
    "DRSAccessURL": {
      "properties": {
        "headers": {
          "description": "An optional list of headers to include in the HTTP request to `url`. These headers can be used to provide auth tokens required to fetch the object bytes.",
          "example": {
            "Authorization": "Basic Z2E0Z2g6ZHJz"
          },
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "url": {
          "description": "A fully resolvable URL that can be used to fetch the actual object bytes.",
          "type": "string"
        }
      },
      "required": [
        "url"
      ],
      "type": "object"
    },
    "DRSAuthorizations": {
      "properties": {
        "bearer_auth_issuers": {
          "description": "If authorizations contain `BearerAuth`, this is an optional list of issuers that may authorize access to this object. The caller must provide a token from one of these issuers. If this is empty or missing it is assumed that the caller knows which token to send via other means. It is strongly recommended that the caller validate that it is appropriate to send the requested token to the DRS server to mitigate attacks by malicious DRS servers requesting credentials they should not have.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "passport_auth_issuers": {
          "description": "If authorizations contain `PassportAuth`, this is a required list of visa issuers (as found in a visa's `iss` claim) that may authorize access to this object. The caller must only provide passports that contain visas from this list. It is strongly recommended that the caller validate that it is appropriate to send the requested passport/visa to the DRS server to mitigate attacks by malicious DRS servers requesting credentials they should not have.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "supported_types": {
          "description": "An Optional list of supported authorization types. More than one can be supported and tried in sequence. Defaults to `None` if empty or missing.",
          "items": {
            "enum": [
              "None",
              "BasicAuth",
              "BearerAuth",
              "PassportAuth"
            ],
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DRSChecksum": {
      "properties": {
        "checksum": {
          "description": "The hex-string encoded checksum for the data",
          "type": "string"
        },
        "type": {
          "description": "The digest method used to create the checksum. If left unspecified md5 will be assumed.\npossible values: md5                # most blob stores provide a checksum using this etag               # multipart uploads to blob stores sha256 sha512",
          "type": "string"
        }
      },
      "required": [
        "checksum"
      ],
      "type": "object"
    },
    "DRSContentsObject": {
      "properties": {
        "contents": {
          "description": "If this ContentsObject describes a nested bundle and the caller specified \"?expand=true\" on the request, then this contents array must be present and describe the objects within the nested bundle.",
          "items": {
            "$ref": "#/definitions/DRSContentsObject"
          },
          "type": "array"
        },
        "drs_uri": {
          "description": "A list of full DRS identifier URI paths that may be used to obtain the object. These URIs may be external to this DRS instance.",
          "example": "drs://example.com/ga4gh/drs/v1/objects/{object_id}",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "id": {
          "description": "A DRS identifier of an `Object` (either a single blob or a nested bundle). If this ContentsObject is an object within a nested bundle, then the id is optional. Otherwise, the id is required.",
          "type": "string"
        },
        "name": {
          "description": "A name declared by the bundle author that must be used when materialising this object, overriding any name directly associated with the object itself. The name must be unique with the containing bundle. This string is made up of uppercase and lowercase letters, decimal digits, hypen, period, and underscore [A-Za-z0-9.-_]. See http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_282[portable filenames].",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "DRSError": {
      "description": "An object that can optionally include information about the error.",
      "properties": {
        "msg": {
          "description": "A detailed error message.",
          "type": "string"
        },
        "status_code": {
          "description": "The integer representing the HTTP status code (e.g. 200, 404).",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DRSObject": {
      "properties": {
        "access_methods": {
          "description": "The list of access methods that can be used to fetch the `Object`. Required for single blobs; optional for bundles.",
          "items": {
            "$ref": "#/definitions/DRSAccessMethod"
          },
          "minItems": 1,
          "type": "array"
        },
        "aliases": {
          "description": "A list of strings that can be used to find other metadata about this `Object` from external metadata sources. These aliases can be used to represent secondary accession numbers or external GUIDs.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "checksums": {
          "description": "The checksum of the `Object`. At least one checksum must be provided. For blobs, the checksum is computed over the bytes in the blob.\nFor bundles, the checksum is computed over a sorted concatenation of the checksums of its top-level contained objects (not recursive, names not included). The list of checksums is sorted alphabetically (hex-code) before concatenation and a further checksum is performed on the concatenated checksum value.\nFor example, if a bundle contains blobs with the following checksums: md5(blob1) = 72794b6d md5(blob2) = 5e089d29\nThen the checksum of the bundle is: md5( concat( sort( md5(blob1), md5(blob2) ) ) ) = md5( concat( sort( 72794b6d, 5e089d29 ) ) ) = md5( concat( 5e089d29, 72794b6d ) ) = md5( 5e089d2972794b6d ) = f7a29a04",
          "items": {
            "$ref": "#/definitions/DRSChecksum"
          },
          "minItems": 1,
          "type": "array"
        },
        "contents": {
          "description": "If not set, this `Object` is a single blob. If set, this `Object` is a bundle containing the listed `ContentsObject` s (some of which may be further nested).",
          "items": {
            "$ref": "#/definitions/DRSContentsObject"
          },
          "type": "array"
        },
        "created_time": {
          "description": "Timestamp of object creation in RFC3339.",
          "type": "string"
        },
        "description": {
          "description": "A human readable description of the `Object`.",
          "type": "string"
        },
        "id": {
          "description": "An identifier unique to this `Object`.",
          "type": "string"
        },
        "mime_type": {
          "description": "A string providing the mime-type of the `Object`.",
          "example": "application/json",
          "type": "string"
        },
        "name": {
          "description": "A string that can be used to name an `Object`. This string is made up of uppercase and lowercase letters, decimal digits, hypen, period, and underscore [A-Za-z0-9.-_]. See http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap03.html#tag_03_282[portable filenames].",
          "type": "string"
        },
        "self_uri": {
          "description": "A drs:// URI, as defined in the DRS documentation, that tells clients how to access this object. The intent of this field is to make DRS objects self-contained, and therefore easier for clients to store and pass around.",
          "example": "drs://drs.example.org/314159",
          "type": "string"
        },
        "size": {
          "description": "For blobs, the blob size in bytes. For bundles, the cumulative size, in bytes, of items in the `contents` field.",
          "format": "int64",
          "type": "integer"
        },
        "updated_time": {
          "description": "Timestamp of `Object` update in RFC3339, identical to create timestamp in systems that do not support updates.",
          "type": "string"
        },
        "version": {
          "description": "A string representing a version. (Some systems may use checksum, a RFC3339 timestamp, or an incrementing version number.)",
          "type": "string"
        }
      },
      "required": [
        "checksums",
        "id",
        "self_uri",
        "size"
      ],
      "type": "object"
    },
    "DRSPassportRequestModel": {
      "properties": {
        "expand": {
          "default": false,
          "description": "If false and the object_id refers to a bundle, then the ContentsObject array contains only those objects directly contained in the bundle. That is, if the bundle contains other bundles, those other bundles are not recursively included in the result.\nIf true and the object_id refers to a bundle, then the entire set of objects in the bundle is expanded. That is, if the bundle contains aother bundles, then those other bundles are recursively expanded and included in the result. Recursion continues through the entire sub-tree of the bundle.\nIf the object_id refers to a blob, then the query parameter is ignored.",
          "example": false,
          "type": "boolean"
        },
        "passports": {
          "description": "the encoded JWT GA4GH Passport that contains embedded Visas.  The overall JWT is signed as are the individual Passport Visas.",
          "items": {
            "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJnYTRnaF9wYXNzcG9ydF92MSI6W119.JJ5rN0ktP0qwyZmIPpxmF_p7JsxAZH6L6brUxtad3CM",
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "passports"
      ],
      "type": "object"
    },
    "DRSServiceInfo": {
      "description": "Useful information about the running service.",
      "properties": {
        "contact": {
          "description": "Maintainer contact info",
          "properties": {},
          "type": "object"
        },
        "description": {
          "description": "Service description",
          "type": "string"
        },
        "license": {
          "description": "License information for the exposed API",
          "properties": {},
          "type": "object"
        },
        "title": {
          "description": "Service name",
          "type": "string"
        },
        "version": {
          "description": "Service version",
          "type": "string"
        }
      },
      "required": [
        "version"
      ],
      "type": "object"
    },
    "DataDeletionGcsFileModel": {
      "description": "a specification of a gcs file containing row ids to delete\n",
      "properties": {
        "fileType": {
          "enum": [
            "csv"
          ],
          "type": "string"
        },
        "path": {
          "description": "a gs://path/to/a/file that can include a wildcard (*)",
          "type": "string"
        }
      },
      "required": [
        "fileType",
        "path"
      ],
      "type": "object"
    },
    "DataDeletionJsonArrayModel": {
      "description": "a specification of row ids to delete\n",
      "properties": {
        "rowIds": {
          "items": {
            "format": "uuid",
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "rowIds"
      ],
      "type": "object"
    },
    "DataDeletionRequest": {
      "description": "a container holding a specification for how to delete tabular data in one or more tables\n",
      "properties": {
        "deleteType": {
          "enum": [
            "soft"
          ],
          "type": "string"
        },
        "specType": {
          "enum": [
            "gcsFile",
            "jsonArray"
          ],
          "type": "string"
        },
        "tables": {
          "items": {
            "$ref": "#/definitions/DataDeletionTableModel"
          },
          "type": "array"
        },
        "transactionId": {
          "description": "If specified, the deleted data will remain visible to users and snapshot creation until the transaction in question is committed. If the transaction is rolled back, then the changes from this delete and any other operations using this transaction will be undone.\n",
          "format": "uuid",
          "type": "string"
        }
      },
      "required": [
        "deleteType",
        "specType"
      ],
      "type": "object"
    },
    "DataDeletionTableModel": {
      "description": "a specification for how to delete tabular data in one table\n",
      "properties": {
        "gcsFileSpec": {
          "$ref": "#/definitions/DataDeletionGcsFileModel"
        },
        "jsonArraySpec": {
          "$ref": "#/definitions/DataDeletionJsonArrayModel"
        },
        "tableName": {
          "description": "the name of a table in the dataset",
          "type": "string"
        }
      },
      "required": [
        "tableName"
      ],
      "type": "object"
    },
    "DatasetDataModel": {
      "description": "Data from a dataset table\n",
      "properties": {
        "filteredRowCount": {
          "type": "integer"
        },
        "result": {
          "description": "Data from a dataset table",
          "items": {
            "type": "object"
          },
          "type": "array"
        },
        "totalRowCount": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DatasetModel": {
      "description": "Complete definition of a dataset.\n",
      "properties": {
        "tags": {
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "type": "array"
        },
        "accessInformation": {
          "$ref": "#/definitions/AccessInfoModel"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "createdDate": {
          "description": "Date the dataset was created",
          "type": "string"
        },
        "dataProject": {
          "description": "Project id of the project where tabular data in BigQuery lives",
          "type": "string"
        },
        "defaultProfileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "defaultSnapshotId": {
          "description": "Id of the auto-generated default passthru snapshot",
          "type": "string"
        },
        "description": {
          "description": "Description of the dataset",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "ingestServiceAccount": {
          "description": "Google service account which must be granted `storage.objects.get` permissions on any source buckets that TDR will ingest data from.\n",
          "type": "string"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "phsId": {
          "$ref": "#/definitions/PhsId"
        },
        "predictableFileIds": {
          "default": false,
          "description": "If false, random ids will be created. If true, full target path (e.g. path + name), size and md5 hash will be used\nNote: this only applies to files.  Directories still have random ids regardless of this value\n",
          "type": "boolean"
        },
        "properties": {
          "description": "Additional JSON metadata about the dataset (this does not need to adhere to a particular schema)",
          "type": "object"
        },
        "resourceLocks": {
          "$ref": "#/definitions/ResourceLocks"
        },
        "schema": {
          "$ref": "#/definitions/DatasetSpecificationModel"
        },
        "secureMonitoringEnabled": {
          "default": false,
          "type": "boolean"
        },
        "selfHosted": {
          "default": false,
          "description": "denotes whether data files in the dataset are self-hosted or not",
          "type": "boolean"
        },
        "snapshotBuilderSettings": {
          "$ref": "#/definitions/SnapshotBuilderSettings"
        },
        "storage": {
          "items": {
            "$ref": "#/definitions/StorageResourceModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DatasetPatchRequestModel": {
      "description": "A 'lite' dataset definition (used to modify supported fields of a dataset). Null assignments will be ignored.\n",
      "properties": {
        "description": {
          "description": "Description of the dataset",
          "type": "string"
        },
        "phsId": {
          "$ref": "#/definitions/PhsId"
        },
        "properties": {
          "description": "Additional JSON metadata about the dataset (this does not need to adhere to a particular schema)",
          "type": "object"
        }
      },
      "type": "object"
    },
    "DatasetRequestAccessIncludeModel": {
      "description": "Type of information to include in the response\n",
      "enum": [
        "NONE",
        "SCHEMA",
        "ACCESS_INFORMATION",
        "PROFILE",
        "PROPERTIES",
        "DATA_PROJECT",
        "STORAGE",
        "SNAPSHOT_BUILDER_SETTINGS"
      ],
      "type": "string"
    },
    "DatasetRequestModel": {
      "description": "Complete definition of a dataset without the id (used to create a dataset)\n",
      "properties": {
        "tags": {
          "$ref": "#/definitions/ResourceCreateTags"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "dedicatedIngestServiceAccount": {
          "default": true,
          "description": "This field is only relevant for GCP-backed datasets. If true, a unique service account will be created in the dataset's primary GCP project, registered in Terra, and used to facilitate ingests. If false, TDR's general service account will be used.\n\nThe dataset's service account can be found when retrieving the dataset.  Whether it is dedicated or general, it must be granted `storage.objects.get` permissions on any source buckets that TDR will ingest data from. This can be done by giving the service account the \"Storage Object Viewer\", \"Storage Legacy Object Reader\", or \"Storage Legacy Object Owner\" role on the source buckets.\n\nTDR recommends that this be set to true:\n\n- A dedicated account that explicitly does not have access to other buckets is more\n  secure and isolated from issues that could impact the general account.\n- Up to 2.5x speed improvements when ingesting files. TDR can bypass the costly\n  permission checking of all user-specified GCP files to ingest if the dataset has a\n  dedicated service account. Such accounts are unique to the dataset and ingests will\n  correctly fail if they lack needed permission on the files. Otherwise, we must\n  perform this check to ensure that a user cannot ingest files inaccessible to them, but\n  accessible to the general TDR service account.\n- Only the dataset's dedicated account must be granted permissions on source ingest\n  buckets.  When using the general account, you must also grant permissions to the Terra\n  proxy user groups for any users triggering ingests.\n- A dedicated service account is less likely to encounter Google group membership quota\n  violations, which is relevant if you need to authorize a large number of buckets.\n",
          "type": "boolean"
        },
        "defaultProfileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "description": {
          "description": "Description of the dataset",
          "type": "string"
        },
        "enableSecureMonitoring": {
          "default": false,
          "type": "boolean"
        },
        "experimentalPredictableFileIds": {
          "default": false,
          "description": "If false, random ids will be created. If true, full target path (e.g. path + name), size and md5 hash will be used\nNote: this only applies to files.  Directories still have random ids regardless of this value\n",
          "type": "boolean"
        },
        "experimentalSelfHosted": {
          "default": false,
          "description": "Create the dataset in self-hosted mode, where TDR does not ingest files, but rather points to files in their original location.",
          "type": "boolean"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "phsId": {
          "$ref": "#/definitions/PhsId"
        },
        "policies": {
          "description": "User emails to add as dataset policy members.",
          "properties": {
            "custodians": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "snapshotCreators": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "stewards": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "properties": {
          "description": "Additional JSON metadata about the dataset (this does not need to adhere to a particular schema)",
          "type": "object"
        },
        "region": {
          "type": "string"
        },
        "schema": {
          "$ref": "#/definitions/DatasetSpecificationModel"
        }
      },
      "required": [
        "defaultProfileId",
        "name",
        "schema"
      ],
      "type": "object"
    },
    "DatasetSchemaColumnUpdateModel": {
      "properties": {
        "columns": {
          "items": {
            "$ref": "#/definitions/ColumnModel"
          },
          "nullable": false,
          "type": "array"
        },
        "tableName": {
          "nullable": false,
          "type": "string"
        }
      },
      "type": "object"
    },
    "DatasetSchemaUpdateModel": {
      "properties": {
        "changes": {
          "nullable": false,
          "properties": {
            "addColumns": {
              "items": {
                "$ref": "#/definitions/DatasetSchemaColumnUpdateModel"
              },
              "nullable": false,
              "type": "array"
            },
            "addRelationships": {
              "items": {
                "$ref": "#/definitions/RelationshipModel"
              },
              "nullable": false,
              "type": "array"
            },
            "addTables": {
              "items": {
                "$ref": "#/definitions/TableModel"
              },
              "nullable": false,
              "type": "array"
            }
          },
          "type": "object"
        },
        "description": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "DatasetSnapshotNameProperty": {
      "description": "Dataset and snapshot names follow this pattern. It is the same as ObjectNameProperty, but has a greater maxLength.\n",
      "maxLength": 511,
      "minLength": 1,
      "pattern": "^[a-zA-Z0-9][_a-zA-Z0-9]*$",
      "type": "string"
    },
    "DatasetSpecificationModel": {
      "description": "data model definition",
      "properties": {
        "assets": {
          "items": {
            "$ref": "#/definitions/AssetModel"
          },
          "type": "array"
        },
        "relationships": {
          "items": {
            "$ref": "#/definitions/RelationshipModel"
          },
          "type": "array"
        },
        "tables": {
          "items": {
            "$ref": "#/definitions/TableModel"
          },
          "type": "array"
        }
      },
      "required": [
        "tables"
      ],
      "type": "object"
    },
    "DatasetSummaryModel": {
      "description": "Summary of a dataset.\n",
      "properties": {
        "tags": {
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "type": "array"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "createdDate": {
          "description": "Date the dataset was created",
          "type": "string"
        },
        "dataProject": {
          "description": "The google project of this dataset",
          "type": "string"
        },
        "defaultProfileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "description": {
          "description": "Description of the dataset",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "phsId": {
          "$ref": "#/definitions/PhsId"
        },
        "predictableFileIds": {
          "default": false,
          "description": "If false, random ids will be created. If true, full target path (e.g. path + name), size and md5 hash will be used\nNote: this only applies to files.  Directories still have random ids regardless of this value\n",
          "type": "boolean"
        },
        "resourceLocks": {
          "$ref": "#/definitions/ResourceLocks"
        },
        "secureMonitoringEnabled": {
          "default": false,
          "type": "boolean"
        },
        "selfHosted": {
          "default": false,
          "description": "denotes whether data files in the dataset are self-hosted or not",
          "type": "boolean"
        },
        "storage": {
          "items": {
            "$ref": "#/definitions/StorageResourceModel"
          },
          "type": "array"
        },
        "storageAccount": {
          "description": "The azure storage account of this dataset",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DatePartitionOptionsModel": {
      "description": "Describes how a date partition should be configured.",
      "properties": {
        "column": {
          "$ref": "#/definitions/ColumnNameProperty"
        }
      },
      "required": [
        "column"
      ],
      "type": "object"
    },
    "DeleteResponseModel": {
      "description": "Returns the state of the object of the deletion\n",
      "properties": {
        "objectState": {
          "enum": [
            "deleted",
            "not_found"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "DirectoryDetailModel": {
      "description": "Directory in the data repository",
      "properties": {
        "contents": {
          "description": "Array of directory contents",
          "items": {
            "$ref": "#/definitions/FileModel"
          },
          "type": "array"
        },
        "enumerated": {
          "description": "Indicates whether or not the directory has been enumerated. True means the directory has been enumerated. The contents property describes the contents. An empty array indicates and empty directory. False means the directory has not been enumerated. If the contents property is present, it should be ignored.\n",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DrsAliasModel": {
      "description": "A mapping from a user provider DRS alias to a TDR DRS object ID",
      "properties": {
        "aliasDrsObjectId": {
          "description": "the alias to a TDR DRS object ID",
          "type": "string"
        },
        "tdrDrsObjectId": {
          "description": "the TDR DRS object ID the alias references",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DuosFirecloudGroupModel": {
      "description": "A Firecloud managed group for the authorized users of a DUOS dataset. This group has a TDR service account as its sole administrator. Only those DUOS datasets known to TDR will have Firecloud groups for their users.\n",
      "properties": {
        "created": {
          "description": "Time when TDR created this group",
          "type": "string"
        },
        "createdBy": {
          "description": "The TDR service account which created this group",
          "example": "jade-k8-sa@broad-jade-dev.iam.gserviceaccount.com",
          "type": "string"
        },
        "duosId": {
          "$ref": "#/definitions/DuosId"
        },
        "firecloudGroupEmail": {
          "description": "Email of Firecloud managed group",
          "example": "DUOS-123456-users@dev.test.firecloud.org",
          "type": "string"
        },
        "firecloudGroupName": {
          "description": "Name of Firecloud managed group",
          "example": "DUOS-123456-users",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "lastSynced": {
          "description": "Last time TDR queried DUOS for its dataset's authorized users",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DuosFirecloudGroupsSyncResponse": {
      "description": "The outcome of a batch sync of all DUOS Firecloud groups.\n",
      "properties": {
        "errors": {
          "description": "Errors which may have interfered in the syncing for select DUOS Firecloud groups.\n",
          "items": {
            "$ref": "#/definitions/ErrorModel"
          },
          "type": "array"
        },
        "synced": {
          "description": "The Firecloud groups whose contents were successfully updated.\n",
          "items": {
            "$ref": "#/definitions/DuosFirecloudGroupModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DuosId": {
      "description": "DUOS dataset identifier",
      "example": "DUOS-123456",
      "type": "string"
    },
    "EnumerateBillingProfileModel": {
      "description": "The total number of billing profiles available and a page of profiles\n",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/BillingProfileModel"
          },
          "type": "array"
        },
        "total": {
          "description": "Total number of billing profiles",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "EnumerateDatasetModel": {
      "description": "The total number of datasets available that match the filter criteria and a page of summaries\n",
      "properties": {
        "filteredTotal": {
          "description": "The number of datasets included in this enumeration",
          "type": "integer"
        },
        "items": {
          "items": {
            "$ref": "#/definitions/DatasetSummaryModel"
          },
          "type": "array"
        },
        "roleMap": {
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": "Map of datasets to the calling user's roles. The key is the dataset ID and the value is a list of role names.\n",
          "type": "object"
        },
        "total": {
          "description": "Total number of datasets",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "EnumerateSnapshotAccessRequest": {
      "description": "The model for enumerated SnapshotAccessRequests.",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/EnumerateSnapshotAccessRequestItem"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "EnumerateSnapshotAccessRequestItem": {
      "description": "The model for SnapshotAccessRequests when enumerated in a response.",
      "properties": {
        "createdBy": {
          "type": "string"
        },
        "createdDate": {
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "name": {
          "type": "string"
        },
        "researchPurpose": {
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/SnapshotAccessRequestStatus"
        }
      },
      "required": [
        "id",
        "status",
        "createdDate",
        "name",
        "researchPurpose",
        "createdBy"
      ],
      "type": "object"
    },
    "EnumerateSnapshotModel": {
      "description": "The total number of snapshots available that match the criteria and a page of summaries\n",
      "properties": {
        "errors": {
          "description": "Errors encountered which may result in a partial enumeration returned.",
          "items": {
            "$ref": "#/definitions/ErrorModel"
          },
          "type": "array"
        },
        "filteredTotal": {
          "description": "The number of snapshots included in this enumeration",
          "type": "integer"
        },
        "items": {
          "items": {
            "$ref": "#/definitions/SnapshotSummaryModel"
          },
          "type": "array"
        },
        "roleMap": {
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": "Map of snapshots to the calling user's roles. The key is the snapshot ID and the value is a list of role names.\n",
          "type": "object"
        },
        "total": {
          "description": "Total number of snapshots",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "EnumerateSortByParam": {
      "default": "created_date",
      "description": "Fields datasets and snapshots can be sorted by.\n",
      "enum": [
        "name",
        "description",
        "created_date"
      ],
      "type": "string"
    },
    "ErrorModel": {
      "description": "Representation of an error that occurred while processing a request. Some errors provide error details. For example, validation of input may report several problems. Each of those are reported in a separate error detail.\n",
      "properties": {
        "errorDetail": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "message": {
          "type": "string"
        }
      },
      "required": [
        "message"
      ],
      "type": "object"
    },
    "FileDetailModel": {
      "description": "File in the data repository",
      "properties": {
        "accessUrl": {
          "description": "URL of the file in cloud storage",
          "type": "string"
        },
        "datasetId": {
          "description": "Id of the dataset that holds the file",
          "type": "string"
        },
        "loadTag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "mimeType": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "FileLoadModel": {
      "description": "Information needed to copy a file from a source bucket into the dataset bucket. Eventually, this will include attributes of the storage including billing, temperature, geography, etc. But for now...\n",
      "properties": {
        "description": {
          "description": "A human readable description of the contents of the Data Object.",
          "type": "string"
        },
        "loadTag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "md5": {
          "$ref": "#/definitions/Md5OverrideModel"
        },
        "mime_type": {
          "description": "A string providing the mime-type of the Data Object. For example, \"application/json\".",
          "type": "string"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "source_path": {
          "description": "gs URL of the source file to load",
          "type": "string"
        },
        "target_path": {
          "description": "Full path within the dataset where the file should be placed. The path must start with /.\n",
          "type": "string"
        }
      },
      "required": [
        "source_path",
        "target_path"
      ],
      "type": "object"
    },
    "FileModel": {
      "description": "A file or directory in the data repository",
      "properties": {
        "checksums": {
          "description": "Always present for files - checksums; May include md5 and/or crc32c. Present for directories in snapshots - see DRS spec for algorithm for combining checksums of underlying directory contents.\n",
          "items": {
            "$ref": "#/definitions/DRSChecksum"
          },
          "type": "array"
        },
        "collectionId": {
          "description": "Id of the dataset or snapshot directory describing the object",
          "type": "string"
        },
        "created": {
          "description": "timestamp of object creation in RFC3339",
          "type": "string"
        },
        "description": {
          "description": "Human readable description of the file",
          "type": "string"
        },
        "directoryDetail": {
          "$ref": "#/definitions/DirectoryDetailModel"
        },
        "fileDetail": {
          "$ref": "#/definitions/FileDetailModel"
        },
        "fileId": {
          "description": "Unique id of the filesystem object within the dataset",
          "type": "string"
        },
        "fileType": {
          "$ref": "#/definitions/FileModelType"
        },
        "path": {
          "description": "full path of the file in the dataset",
          "type": "string"
        },
        "size": {
          "description": "Always present for files - the file size in bytes Present for directories in snapshots - sum of sizes of objects in a directory\n",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FileModelType": {
      "enum": [
        "file",
        "directory"
      ],
      "type": "string"
    },
    "IamResourceTypeEnum": {
      "description": "The type of journal entries to return.  DATASET maps to Dataset, DATASNAPSHOT maps to Snapshot, SPEND_PROFILE maps to Profile.  DATAREPO and WORKSPACE are not implemented at this time but are included in the list for completeness.\n",
      "enum": [
        "DATASET",
        "DATASNAPSHOT",
        "SPEND_PROFILE",
        "DATAREPO",
        "WORKSPACE"
      ],
      "type": "string"
    },
    "InaccessibleWorkspacePolicyModel": {
      "properties": {
        "error": {
          "$ref": "#/definitions/ErrorModel"
        },
        "workspaceId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "workspacePolicies": {
          "items": {
            "$ref": "#/definitions/PolicyModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "IngestRequestModel": {
      "description": "Request to ingest data from a file in GCS into a table in a dataset. The ingest source must be readable by the DR manager. TODO: other input forms\n",
      "properties": {
        "bulkMode": {
          "default": false,
          "description": "If true, file ingest will be performed in bulk mode.  The tradeoff for the performance improvements are that: - the dataset will be locked exclusively - some safeguards can not be enforced during loads.  Given that, it's recommended that\n  you use a max_failed_file_loads value of 0\n- the assumption is that file metadata must all fit into memory so configure the\n  deployment accordingly\n",
          "type": "boolean"
        },
        "csv_allow_quoted_newlines": {
          "default": true,
          "type": "boolean"
        },
        "csv_field_delimiter": {
          "default": ",",
          "description": "field separator",
          "type": "string"
        },
        "csv_generate_row_ids": {
          "default": true,
          "description": "Whether the data repo should generate datarepo_row_ids on CSV ingest. Defaults to true.",
          "type": "boolean"
        },
        "csv_null_marker": {
          "default": "",
          "type": "string"
        },
        "csv_quote": {
          "default": "\"",
          "description": "quoting character",
          "type": "string"
        },
        "csv_skip_leading_rows": {
          "description": "number of header rows to skip",
          "type": "integer"
        },
        "format": {
          "description": "format of the data to ingest.  Currently supported formats are `csv`, `json`, and `array` `array` indicates loading from a JSON object payload in the records field.\nNote: when ingesting from a CSV file into an Azure dataset, no string or text field may be larger than 8000 bytes\n",
          "enum": [
            "csv",
            "json",
            "array"
          ],
          "type": "string"
        },
        "ignore_unknown_values": {
          "default": true,
          "description": "skip extra data; applies to all ingest formats",
          "type": "boolean"
        },
        "load_tag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "max_bad_records": {
          "default": 0,
          "description": "max number of bad records to skip; applies to all ingest formats",
          "type": "integer"
        },
        "max_failed_file_loads": {
          "default": 0,
          "description": "max number of failed file loads before stopping; if -1, allow any number of errors",
          "type": "integer"
        },
        "path": {
          "description": "cloud path to a file in a bucket accessible to data repo (e.g. gs path for GCP datasets or https path for Azure datasets).  Required if the format is `csv` or `json`. Do not specify if the ingest format is `array`\n",
          "type": "string"
        },
        "profile_id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "records": {
          "description": "an array of json metadata records to ingest\n",
          "items": {
            "description": "a representation of a record to ingest in the form of `{\"sColumn\":\"string value\", \"nColumn\":123, \"lValue\":[\"a\",\"b\"]...}`\n",
            "type": "object"
          },
          "type": "array"
        },
        "resolve_existing_files": {
          "default": false,
          "description": "When true, the combined ingest will look for files that already exist and substitute their fileIds in instead of ingesting duplicate files.\n",
          "type": "boolean"
        },
        "table": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "transactionId": {
          "description": "If specified, the ingested data will remain invisible to users and snapshot creation until the transaction in question is committed. If the transaction is rolled back, then the changes from this ingest and any other operations using this transaction will be undone.\n",
          "format": "uuid",
          "type": "string"
        },
        "updateStrategy": {
          "description": "Approach for how to treat updates to the target table:\n * `append` - Default: only ever insert rows, regardless of whether or not the primary key value exists\n * `replace` - If a primary key is present on the table, treat rows with matching primary keys\n             as updates. If duplicate IDs are found in your ingest, the ingest job\n             will fail. If your rows specify `datarepo_row_id`, it will be ignored and\n             TDR will generate new row IDs for your new records. Note: the full new\n             record must be specified.\n * `merge` - If a primary key is present on the table, treat rows with matching primary keys\n             as partial updates. Any fields specified will overwrite their current values\n             in the matching table row. If your rows specify `datarepo_row_id`, it will\n             be ignored and TDR will generate new row IDs for your new records. Each\n             ingest row must match exactly one table row, and no duplicate IDs should be\n             found in your ingest, otherwise the ingest job will fail.\n",
          "enum": [
            "append",
            "replace",
            "merge"
          ],
          "type": "string"
        }
      },
      "required": [
        "format",
        "table",
        "max_bad_records",
        "max_failed_file_loads"
      ],
      "type": "object"
    },
    "IngestResponseModel": {
      "description": "Response from performing an ingest.\n",
      "properties": {
        "bad_row_count": {
          "description": "number of bad rows skipped",
          "format": "int64",
          "type": "integer"
        },
        "dataset": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "dataset_id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "load_result": {
          "$ref": "#/definitions/BulkLoadArrayResultModel"
        },
        "load_tag": {
          "$ref": "#/definitions/LoadTagModel"
        },
        "path": {
          "type": "string"
        },
        "row_count": {
          "description": "number of rows successfully ingested",
          "format": "int64",
          "type": "integer"
        },
        "table": {
          "$ref": "#/definitions/ObjectNameProperty"
        }
      },
      "required": [
        "path",
        "row_count",
        "table"
      ],
      "type": "object"
    },
    "IntPartitionOptionsModel": {
      "description": "Describes how an int partition should be configured.",
      "properties": {
        "column": {
          "$ref": "#/definitions/ColumnNameProperty"
        },
        "interval": {
          "description": "The size to use when dividing the partitioning range into \"buckets\". (max - min) / (this value) cannot be larger than 4,000.\n",
          "format": "int64",
          "type": "integer"
        },
        "max": {
          "description": "The largest value to partition within the target column. Any rows with a value larger than this will be unpartitioned.\n",
          "format": "int64",
          "type": "integer"
        },
        "min": {
          "description": "The smallest value to partition within the target column. Any rows with a value smaller than this will be unpartitioned.\n",
          "format": "int64",
          "type": "integer"
        }
      },
      "required": [
        "column",
        "interval",
        "max",
        "min"
      ],
      "type": "object"
    },
    "JobModel": {
      "description": "Status of job\n",
      "properties": {
        "class_name": {
          "description": "Class name of the flight",
          "type": "string"
        },
        "completed": {
          "description": "Timestamp when the flight was completed; not present if not complete",
          "type": "string"
        },
        "description": {
          "description": "Description of the job's flight from description flight input parameter",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/ShortIdProperty"
        },
        "job_status": {
          "description": "Status of job",
          "enum": [
            "running",
            "succeeded",
            "failed"
          ],
          "type": "string"
        },
        "status_code": {
          "description": "HTTP code",
          "type": "integer"
        },
        "submitted": {
          "description": "Timestamp when the flight was created",
          "type": "string"
        }
      },
      "required": [
        "id",
        "job_status",
        "status_code"
      ],
      "type": "object"
    },
    "JournalEntryModel": {
      "properties": {
        "className": {
          "description": "the class name that made this journal entry",
          "type": "string"
        },
        "entryType": {
          "description": "the type of journal entry created",
          "enum": [
            "CREATE",
            "UPDATE",
            "DELETE"
          ],
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "methodName": {
          "description": "the method name that made this journal entry",
          "type": "string"
        },
        "mutation": {
          "description": "An optional map included with the journal entry.  Entries in the map ending with .json are entries that likely contain JSON encoded strings.",
          "type": "object"
        },
        "note": {
          "description": "A note about the journal entry",
          "type": "string"
        },
        "resourceKey": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "resourceType": {
          "$ref": "#/definitions/IamResourceTypeEnum"
        },
        "user": {
          "description": "the email address of the user who performed this action",
          "type": "string"
        },
        "when": {
          "description": "timestamp of journal entry creation",
          "type": "string"
        }
      },
      "required": [
        "id",
        "resourceKey",
        "user",
        "entryType",
        "resourceType",
        "className",
        "methodName",
        "when"
      ],
      "type": "object"
    },
    "LoadTagModel": {
      "description": "client-specified tag for a data or file load. If no id is specified, we use the string form of the job create time as the tag.\n",
      "type": "string"
    },
    "Md5OverrideModel": {
      "description": "A hex representation of the  md5 for the file.  If an md5 exists for the file being ingested, it will be validated against this value and the file's ingest will fail if the values do not match.  If no md5 hash is present on the file being ingested, this value will be stored for the file.  If this value is not specified, then the md5 from the file being ingested (from the cloud provider) will be used\n",
      "type": "string"
    },
    "ObjectNameProperty": {
      "description": "Table names follow this pattern. This should be used for the name of any non-column object in the system. It enforces BigQuery naming rules except it disallows a leading underscore so we avoid collisions with any extra tables the DR adds. For table names, this is shorter than what BigQuery allows.\n",
      "maxLength": 63,
      "minLength": 1,
      "pattern": "^[a-zA-Z0-9][_a-zA-Z0-9]*$",
      "type": "string"
    },
    "PhsId": {
      "description": "PHS ID (DbGap Phenotype Study Identifer) associated with dataset",
      "example": "phs123456",
      "type": "string"
    },
    "PolicyMemberRequest": {
      "description": "email of user or group to add to policy\n",
      "properties": {
        "email": {
          "type": "string"
        }
      },
      "required": [
        "email"
      ],
      "type": "object"
    },
    "PolicyModel": {
      "description": "Describes a policy\n",
      "properties": {
        "members": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "PolicyResponse": {
      "description": "email of user or group to add to policy\n",
      "properties": {
        "authDomain": {
          "items": {
            "description": "The Sam user groups that define this auth domain",
            "type": "string"
          },
          "type": "array"
        },
        "inaccessibleWorkspaces": {
          "items": {
            "$ref": "#/definitions/InaccessibleWorkspacePolicyModel"
          },
          "type": "array"
        },
        "policies": {
          "items": {
            "$ref": "#/definitions/PolicyModel"
          },
          "type": "array"
        },
        "workspaces": {
          "items": {
            "$ref": "#/definitions/WorkspacePolicyModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "QueryColumnStatisticsRequestModel": {
      "properties": {
        "filter": {
          "description": "A SQL WHERE clause to filter results included in column statistics.\n\nFor GCP array string columns, if you wanted to include all rows that contain 'value1' in column1, the filter clause would look like 'WHERE 'value1' IN UNNEST(column1)'. Note that \"count\" value includes all occurrences of a value including duplicates of the same value in a single array. i.e. if we had two rows in a table where the value for column1, row1 = ['value1', 'value1', 'value2'] and column1, row2 = ['value1'] the count for 'value1' would be 3.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "QueryDataRequestModel": {
      "properties": {
        "direction": {
          "$ref": "#/definitions/SqlSortDirectionAscDefault"
        },
        "filter": {
          "default": "",
          "description": "A SQL WHERE clause to filter the table results.",
          "type": "string"
        },
        "limit": {
          "default": 30,
          "description": "The number of rows to return for the data",
          "maximum": 1000,
          "minimum": 1,
          "type": "integer"
        },
        "offset": {
          "default": 0,
          "description": "The number of rows to skip when retrieving the next page",
          "minimum": 0,
          "type": "integer"
        },
        "sort": {
          "default": "datarepo_row_id",
          "description": "The table column to sort by",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RelationshipModel": {
      "description": "One relationship between two tables. Captures a specific relationship between two tables. By naming the relationships, we can define assets.\n",
      "properties": {
        "from": {
          "$ref": "#/definitions/RelationshipTermModel"
        },
        "name": {
          "minLength": 1,
          "type": "string"
        },
        "to": {
          "$ref": "#/definitions/RelationshipTermModel"
        }
      },
      "required": [
        "from",
        "name",
        "to"
      ],
      "type": "object"
    },
    "RelationshipTermModel": {
      "description": "Describes a table and columns for a relationship",
      "properties": {
        "column": {
          "$ref": "#/definitions/ColumnNameProperty"
        },
        "table": {
          "$ref": "#/definitions/ObjectNameProperty"
        }
      },
      "required": [
        "column",
        "table"
      ],
      "type": "object"
    },
    "RepositoryConfigurationModel": {
      "properties": {
        "activeProfiles": {
          "description": "the active profiles for this instance",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "authorityEndpoint": {
          "description": "the URI of oauth authority for the UI to use (e.g. .well-known/openid-configuration gets appended to it)",
          "format": "uri",
          "type": "string"
        },
        "clientId": {
          "description": "the Oauth client id for the repository",
          "type": "string"
        },
        "duosUrl": {
          "description": "the URI of DUOS this instance uses",
          "format": "uri",
          "type": "string"
        },
        "gitHash": {
          "description": "the git hash of the data repository",
          "type": "string"
        },
        "oidcClientId": {
          "description": "the Oauth client id for the OpenID Connect config for the repository",
          "type": "string"
        },
        "samUrl": {
          "description": "the URI of Sam this instance uses",
          "format": "uri",
          "type": "string"
        },
        "semVer": {
          "description": "the semantic version of the data repository",
          "type": "string"
        },
        "terraUrl": {
          "description": "the url to the corresponding terra environment",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RepositoryStatusModel": {
      "description": "Returns the status of monitored subsystems.",
      "properties": {
        "ok": {
          "description": "status of this service",
          "type": "boolean"
        },
        "systems": {
          "additionalProperties": {
            "properties": {
              "critical": {
                "type": "boolean"
              },
              "message": {
                "type": "string"
              },
              "ok": {
                "type": "boolean"
              }
            },
            "type": "object"
          },
          "type": "object"
        }
      },
      "required": [
        "ok",
        "systems"
      ],
      "type": "object"
    },
    "ResourceCreateTags": {
      "description": "Tags to add to the resource on its creation.  User-inputted tags will be stripped of leading and trailing whitespace, filtered of empty elements, and deduplicated.\n",
      "items": {
        "$ref": "#/definitions/Tag"
      },
      "type": "array"
    },
    "ResourceLocks": {
      "description": "An exclusive lock on a resource may prevent other resource modifications from running concurrently.\n",
      "properties": {
        "exclusive": {
          "$ref": "#/definitions/ShortIdProperty"
        },
        "shared": {
          "items": {
            "$ref": "#/definitions/ShortIdProperty"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ResourcePolicyModel": {
      "properties": {
        "policyEmail": {
          "type": "string"
        },
        "policyName": {
          "type": "string"
        },
        "resourceId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "resourceTypeName": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SamPolicyModel": {
      "description": "Describes a policy from Sam, with member policies\n",
      "properties": {
        "memberPolicies": {
          "items": {
            "$ref": "#/definitions/ResourcePolicyModel"
          },
          "type": "array"
        },
        "members": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "ShortIdProperty": {
      "description": "Unique identifier for flights, jobs, etc.\n",
      "pattern": "[A-Za-z0-9_\\\\-]{22}",
      "type": "string"
    },
    "SnapshotAccessRequest": {
      "description": "Request for access to a snapshot.",
      "properties": {
        "datasetRequest": {
          "$ref": "#/definitions/SnapshotBuilderRequest"
        },
        "name": {
          "type": "string"
        },
        "researchPurposeStatement": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SnapshotAccessRequestResponse": {
      "description": "The response object for a submitted SnapshotAccessRequest.",
      "properties": {
        "createdBy": {
          "type": "string"
        },
        "createdDate": {
          "type": "string"
        },
        "datasetId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "snapshotName": {
          "type": "string"
        },
        "snapshotResearchPurpose": {
          "type": "string"
        },
        "snapshotSpecification": {
          "$ref": "#/definitions/SnapshotBuilderRequest"
        },
        "status": {
          "$ref": "#/definitions/SnapshotAccessRequestStatus"
        },
        "updatedDate": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "datasetId",
        "snapshotName",
        "snapshotResearchPurpose",
        "snapshotSpecification",
        "createdBy",
        "createdDate",
        "status"
      ],
      "type": "object"
    },
    "SnapshotAccessRequestStatus": {
      "enum": [
        "SUBMITTED",
        "APPROVED",
        "REJECTED"
      ],
      "type": "string"
    },
    "SnapshotBuilderCohort": {
      "description": "Selection of participants.",
      "properties": {
        "criteriaGroups": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderCriteriaGroup"
          },
          "type": "array"
        },
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderConcept": {
      "description": " An object describing a concept in the Snapshot Builder\n",
      "properties": {
        "code": {
          "type": "string"
        },
        "count": {
          "type": "integer"
        },
        "hasChildren": {
          "type": "boolean"
        },
        "id": {
          "type": "integer"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "id",
        "name",
        "hasChildren"
      ],
      "type": "object"
    },
    "SnapshotBuilderCountRequest": {
      "properties": {
        "cohorts": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderCohort"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderCountResponse": {
      "properties": {
        "result": {
          "properties": {
            "total": {
              "type": "integer"
            }
          },
          "type": "object"
        },
        "sql": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderCriteria": {
      "discriminator": "kind",
      "properties": {
        "id": {
          "description": "the ID of either the domain or program data entry",
          "type": "integer"
        },
        "kind": {
          "enum": [
            "list",
            "range",
            "domain"
          ],
          "type": "string"
        }
      },
      "required": [
        "kind",
        "id"
      ],
      "type": "object"
    },
    "SnapshotBuilderCriteriaGroup": {
      "description": "Criteria Group specifying a Cohort.",
      "properties": {
        "count": {
          "type": "number"
        },
        "criteria": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderCriteria"
          },
          "type": "array"
        },
        "meetAll": {
          "type": "boolean"
        },
        "mustMeet": {
          "type": "boolean"
        },
        "name": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderDatasetConceptSet": {
      "description": " A concept set provided for the dataset, usually used to access tables that are not searchable as domains\n",
      "properties": {
        "concept": {
          "$ref": "#/definitions/SnapshotBuilderConcept"
        },
        "featureValueGroupName": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "featureValueGroupName"
      ],
      "type": "object"
    },
    "SnapshotBuilderDomainCriteria": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderCriteria"
        },
        {
          "properties": {
            "conceptId": {
              "type": "integer"
            }
          },
          "required": "-conceptId",
          "type": "object"
        }
      ],
      "description": "Selection of a domain concept id, part of a CriteriaGroup.",
      "x-discriminator-value": "domain",
      "x-ms-discriminator-value": "domain"
    },
    "SnapshotBuilderDomainOption": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderOption"
        },
        {
          "properties": {
            "conceptCount": {
              "type": "integer"
            },
            "participantCount": {
              "type": "integer"
            },
            "root": {
              "$ref": "#/definitions/SnapshotBuilderConcept"
            }
          },
          "required": [
            "root"
          ],
          "type": "object"
        }
      ],
      "description": " An object describing high level information about a domain for use in the snapshot builder\n",
      "x-discriminator-value": "domain",
      "x-ms-discriminator-value": "domain"
    },
    "SnapshotBuilderFeatureValueGroup": {
      "description": " Describes a set of columns for a table with given name\n",
      "properties": {
        "name": {
          "type": "string"
        },
        "values": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "values"
      ],
      "type": "object"
    },
    "SnapshotBuilderGetConceptHierarchyResponse": {
      "description": " The response object for the getConceptHierarchy endpoint\n",
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderParentConcept"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderGetConceptsResponse": {
      "description": " The response object for the getConcepts endpoint\n",
      "properties": {
        "result": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderConcept"
          },
          "type": "array"
        },
        "sql": {
          "type": "string"
        }
      },
      "required": [
        "result"
      ],
      "type": "object"
    },
    "SnapshotBuilderOption": {
      "discriminator": "kind",
      "properties": {
        "columnName": {
          "type": "string"
        },
        "id": {
          "description": "the ID of either the domain or program data entry",
          "type": "integer"
        },
        "kind": {
          "enum": [
            "list",
            "range",
            "domain"
          ],
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "tableName": {
          "type": "string"
        }
      },
      "required": [
        "kind",
        "id",
        "name",
        "tableName",
        "columnName"
      ],
      "type": "object"
    },
    "SnapshotBuilderParentConcept": {
      "description": " An object describing a parent concept in the Snapshot Builder\n",
      "properties": {
        "children": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderConcept"
          },
          "type": "array"
        },
        "parentId": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderProgramDataListCriteria": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderCriteria"
        },
        {
          "properties": {
            "values": {
              "items": {
                "type": "integer"
              },
              "type": "array"
            }
          },
          "required": [
            "values"
          ],
          "type": "object"
        }
      ],
      "description": "List format program data, part of a CriteriaGroup.",
      "x-discriminator-value": "list",
      "x-ms-discriminator-value": "list"
    },
    "SnapshotBuilderProgramDataListItem": {
      "properties": {
        "id": {
          "description": "the ID of the list item in the specified table",
          "type": "integer"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "id"
      ],
      "type": "object"
    },
    "SnapshotBuilderProgramDataListOption": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderProgramDataOption"
        },
        {
          "properties": {
            "values": {
              "items": {
                "$ref": "#/definitions/SnapshotBuilderProgramDataListItem"
              },
              "type": "array"
            }
          },
          "type": "object"
        }
      ],
      "description": "List format program data, part of a CriteriaGroup.",
      "x-discriminator-value": "list",
      "x-ms-discriminator-value": "list"
    },
    "SnapshotBuilderProgramDataOption": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderOption"
        },
        {
          "properties": {
            "kind": {
              "enum": [
                "list",
                "range"
              ],
              "type": "string"
            }
          },
          "type": "object"
        }
      ],
      "discriminator": "kind",
      "x-discriminator-value": "range",
      "x-ms-discriminator-value": "range"
    },
    "SnapshotBuilderProgramDataRangeCriteria": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderCriteria"
        },
        {
          "properties": {
            "high": {
              "type": "integer"
            },
            "low": {
              "type": "integer"
            }
          },
          "required": [
            "low",
            "high"
          ],
          "type": "object"
        }
      ],
      "description": "Range format program data, part of a CriteriaGroup.",
      "x-discriminator-value": "range",
      "x-ms-discriminator-value": "range"
    },
    "SnapshotBuilderProgramDataRangeOption": {
      "allOf": [
        {
          "$ref": "#/definitions/SnapshotBuilderProgramDataOption"
        },
        {
          "properties": {
            "max": {
              "type": "integer"
            },
            "min": {
              "type": "integer"
            }
          },
          "type": "object"
        }
      ],
      "description": "List format program data, part of a CriteriaGroup.",
      "x-discriminator-value": "range",
      "x-ms-discriminator-value": "range"
    },
    "SnapshotBuilderRequest": {
      "description": "Specification of cohort and participant data for a requested snapshot.",
      "properties": {
        "cohorts": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderCohort"
          },
          "type": "array"
        },
        "conceptSets": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderDatasetConceptSet"
          },
          "type": "array"
        },
        "valueSets": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderFeatureValueGroup"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SnapshotBuilderSettings": {
      "description": " The configuration describing how select criteria for issuing a snapshot builder request is generated\n",
      "properties": {
        "datasetConceptSets": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderDatasetConceptSet"
          },
          "type": "array"
        },
        "domainOptions": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderDomainOption"
          },
          "type": "array"
        },
        "featureValueGroups": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderFeatureValueGroup"
          },
          "type": "array"
        },
        "programDataOptions": {
          "items": {
            "$ref": "#/definitions/SnapshotBuilderProgramDataOption"
          },
          "type": "array"
        }
      },
      "required": [
        "domainOptions",
        "programDataOptions",
        "featureValueGroups"
      ],
      "type": "object"
    },
    "SnapshotExportResponseModel": {
      "properties": {
        "format": {
          "properties": {
            "parquet": {
              "properties": {
                "location": {
                  "properties": {
                    "tables": {
                      "items": {
                        "properties": {
                          "paths": {
                            "items": {
                              "description": "path to a parquet file for a table",
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "name": {
                            "description": "Name of the table exported",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                },
                "manifest": {
                  "description": "path to manifest file detailing paths to parquet files",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "workspace": {
              "properties": {
                "link": {
                  "description": "Link to the workspace the snapshot was exported to",
                  "type": "string"
                },
                "name": {
                  "description": "Workspace name the snapshot was exported to",
                  "type": "string"
                },
                "namespace": {
                  "description": "Workspace namespace the snapshot was exported to",
                  "type": "string"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        },
        "snapshot": {
          "$ref": "#/definitions/SnapshotModel"
        },
        "validatedPrimaryKeys": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SnapshotIdsAndRolesModel": {
      "properties": {
        "errors": {
          "description": "Errors encountered which may result in a partial role map returned.",
          "items": {
            "$ref": "#/definitions/ErrorModel"
          },
          "type": "array"
        },
        "roleMap": {
          "additionalProperties": {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": "Map of snapshot IDs to the calling user's roles. The key is the snapshot ID and the value is a list of role names.\n",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SnapshotLinkDuosDatasetResponse": {
      "description": "The DUOS Firecloud groups unlinked from and/or linked to the snapshot.\n",
      "properties": {
        "linked": {
          "$ref": "#/definitions/DuosFirecloudGroupModel"
        },
        "unlinked": {
          "$ref": "#/definitions/DuosFirecloudGroupModel"
        }
      },
      "type": "object"
    },
    "SnapshotModel": {
      "description": "SnapshotModel returns detailed data about an existing snapshot.\n",
      "properties": {
        "tags": {
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "type": "array"
        },
        "accessInformation": {
          "$ref": "#/definitions/AccessInfoModel"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "compactIdPrefix": {
          "$ref": "#/definitions/CompactIdPrefix"
        },
        "consentCode": {
          "$ref": "#/definitions/ConsentCode"
        },
        "createdDate": {
          "description": "Date the snapshot was created",
          "type": "string"
        },
        "creationInformation": {
          "$ref": "#/definitions/SnapshotRequestContentsModel"
        },
        "dataProject": {
          "description": "Project id of the snapshot data project",
          "type": "string"
        },
        "description": {
          "description": "Description of the snapshot",
          "type": "string"
        },
        "duosFirecloudGroup": {
          "$ref": "#/definitions/DuosFirecloudGroupModel"
        },
        "globalFileIds": {
          "default": false,
          "description": "if false, the drs ids will be in the format: v1_<snapshotid>_<fileid> if true, drs ids will be in the format: v2_<fileid>\n",
          "type": "boolean"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "properties": {
          "description": "Additional JSON metadata about the snapshot (this does not need to adhere to a particular schema)",
          "type": "object"
        },
        "relationships": {
          "items": {
            "$ref": "#/definitions/RelationshipModel"
          },
          "type": "array"
        },
        "resourceLocks": {
          "$ref": "#/definitions/ResourceLocks"
        },
        "source": {
          "description": "A singleton collection whose sole element represents the snapshot's source dataset.\n",
          "items": {
            "$ref": "#/definitions/SnapshotSourceModel"
          },
          "type": "array"
        },
        "tables": {
          "items": {
            "$ref": "#/definitions/TableModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "SnapshotPatchRequestModel": {
      "description": "A 'lite' snapshot definition (used to modify supported fields of a snapshot). Null assignments will be ignored.\n",
      "properties": {
        "consentCode": {
          "$ref": "#/definitions/ConsentCode"
        },
        "description": {
          "description": "Description of the snapshot",
          "type": "string"
        },
        "properties": {
          "description": "Additional JSON metadata about the snapshot (this does not need to adhere to a particular schema)",
          "type": "object"
        }
      },
      "type": "object"
    },
    "SnapshotPreviewModel": {
      "description": "A preview of a snapshot table\n",
      "properties": {
        "filteredRowCount": {
          "type": "integer"
        },
        "result": {
          "description": "Preview data of a snapshot table",
          "items": {
            "type": "object"
          },
          "type": "array"
        },
        "totalRowCount": {
          "type": "integer"
        }
      },
      "type": "object"
    },
    "SnapshotRequestAssetModel": {
      "description": "The datasource identifies the dataset and asset from which to source the data.\n",
      "properties": {
        "assetName": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "rootValues": {
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "assetName",
        "rootValues"
      ],
      "type": "object"
    },
    "SnapshotRequestContentsModel": {
      "description": "The contents specifies the source of the data (dataset and asset) and the rows to include (field and rootValues). TODO: field will move the asset object; it is here as a stepping stone\n",
      "properties": {
        "assetSpec": {
          "$ref": "#/definitions/SnapshotRequestAssetModel"
        },
        "datasetName": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "mode": {
          "enum": [
            "byAsset",
            "byFullView",
            "byQuery",
            "byRowId"
          ],
          "type": "string"
        },
        "querySpec": {
          "$ref": "#/definitions/SnapshotRequestQueryModel"
        },
        "rowIdSpec": {
          "$ref": "#/definitions/SnapshotRequestRowIdModel"
        }
      },
      "required": [
        "datasetName",
        "mode"
      ],
      "type": "object"
    },
    "SnapshotRequestModel": {
      "description": "Request for creating a snapshot. For now, the API only supports snapshots defined as a single dataset asset and row ids for the root table of that asset. The snapshot has exactly the tables and columns of the asset. An optional list of users can be provided to set as readers on the snapshot. In the future, we will need to extend this to handle cross-dataset snapshots from disparate assets, so we will need to support column and datatype mapping from asset tables to the target snapshot tables.\n",
      "properties": {
        "tags": {
          "$ref": "#/definitions/ResourceCreateTags"
        },
        "compactIdPrefix": {
          "$ref": "#/definitions/CompactIdPrefix"
        },
        "consentCode": {
          "$ref": "#/definitions/ConsentCode"
        },
        "contents": {
          "items": {
            "$ref": "#/definitions/SnapshotRequestContentsModel"
          },
          "type": "array"
        },
        "description": {
          "description": "Description of the snapshot",
          "type": "string"
        },
        "duosId": {
          "$ref": "#/definitions/DuosId"
        },
        "globalFileIds": {
          "default": false,
          "description": "if false, the drs ids will be in the format: v1_<snapshotid>_<fileid> if true, drs ids will be in the format: v2_<fileid>\n",
          "type": "boolean"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "policies": {
          "description": "User emails to add as snapshot policy members.",
          "properties": {
            "discoverers": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "readers": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "stewards": {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "properties": {
          "description": "Additional JSON metadata about the snapshot (this does not need to adhere to a particular schema)",
          "type": "object"
        },
        "readers": {
          "description": "Deprecated -- use `policies.readers` instead. Any readers specified here will supplement those set in `policies.readers`.\n",
          "items": {
            "type": "string"
          },
          "type": "array",
          "x-deprecated": true
        }
      },
      "required": [
        "contents",
        "name"
      ],
      "type": "object"
    },
    "SnapshotRequestQueryModel": {
      "description": "A specification of the query to go into a snapshot.\n",
      "properties": {
        "assetName": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "query": {
          "type": "string"
        }
      },
      "required": [
        "assetName",
        "query"
      ],
      "type": "object"
    },
    "SnapshotRequestRowIdModel": {
      "description": "Identifies the list of tables + columns along with the row ids to be included in the snapshot\n",
      "properties": {
        "tables": {
          "items": {
            "$ref": "#/definitions/SnapshotRequestRowIdTableModel"
          },
          "type": "array"
        }
      },
      "required": [
        "tables"
      ],
      "type": "object"
    },
    "SnapshotRequestRowIdTableModel": {
      "description": "A specification of a table, columns, and row ids to go into a snapshot.\n",
      "properties": {
        "columns": {
          "items": {
            "$ref": "#/definitions/ColumnNameProperty"
          },
          "type": "array"
        },
        "rowIds": {
          "items": {
            "$ref": "#/definitions/UniqueIdProperty"
          },
          "type": "array"
        },
        "tableName": {
          "$ref": "#/definitions/ObjectNameProperty"
        }
      },
      "required": [
        "columns",
        "rowIds",
        "tableName"
      ],
      "type": "object"
    },
    "SnapshotRetrieveIncludeModel": {
      "description": "Type of information to include in the response\n",
      "enum": [
        "NONE",
        "SOURCES",
        "TABLES",
        "RELATIONSHIPS",
        "ACCESS_INFORMATION",
        "PROFILE",
        "PROPERTIES",
        "DATA_PROJECT",
        "CREATION_INFORMATION",
        "DUOS"
      ],
      "type": "string"
    },
    "SnapshotSourceModel": {
      "description": "SnapshotSourceModel returns data about the source for an existing snapshot\n",
      "properties": {
        "asset": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "dataset": {
          "$ref": "#/definitions/DatasetSummaryModel"
        },
        "datasetProperties": {
          "description": "Additional JSON metadata about the source dataset",
          "type": "object"
        }
      },
      "required": [
        "dataset"
      ],
      "type": "object"
    },
    "SnapshotSummaryModel": {
      "description": "summary of snapshot\n",
      "properties": {
        "tags": {
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "type": "array"
        },
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "consentCode": {
          "$ref": "#/definitions/ConsentCode"
        },
        "createdDate": {
          "description": "Date the snapshot was created",
          "type": "string"
        },
        "dataProject": {
          "description": "The google project of this snapshot",
          "type": "string"
        },
        "description": {
          "description": "Description of the snapshot",
          "type": "string"
        },
        "duosId": {
          "$ref": "#/definitions/DuosId"
        },
        "globalFileIds": {
          "default": false,
          "description": "if false, the drs ids will be in the format: v1_<snapshotid>_<fileid> if true, drs ids will be in the format: v2_<fileid>\n",
          "type": "boolean"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "name": {
          "$ref": "#/definitions/DatasetSnapshotNameProperty"
        },
        "phsId": {
          "$ref": "#/definitions/PhsId"
        },
        "profileId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "resourceLocks": {
          "$ref": "#/definitions/ResourceLocks"
        },
        "secureMonitoringEnabled": {
          "default": false,
          "type": "boolean"
        },
        "selfHosted": {
          "description": "Denotes whether the data files in this snapshot are self hosted or not",
          "type": "boolean"
        },
        "storage": {
          "items": {
            "$ref": "#/definitions/StorageResourceModel"
          },
          "type": "array"
        },
        "storageAccount": {
          "description": "The azure storage account of this snapshot",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SqlSortDirectionAscDefault": {
      "default": "asc",
      "description": "The sort direction of a query result\n",
      "enum": [
        "asc",
        "desc"
      ],
      "type": "string"
    },
    "SqlSortDirectionDescDefault": {
      "default": "desc",
      "description": "The sort direction of a query result\n",
      "enum": [
        "asc",
        "desc"
      ],
      "type": "string"
    },
    "StorageResourceModel": {
      "description": "A model representing the cloud platform, region, and resource of a dataset's infrastructure asset. This is only ever returned to the user, and at this point, is not parsed or pased in as a post body.",
      "properties": {
        "cloudPlatform": {
          "$ref": "#/definitions/CloudPlatform"
        },
        "cloudResource": {
          "type": "string"
        },
        "region": {
          "type": "string"
        }
      },
      "type": "object"
    },
    "TableDataType": {
      "description": "The type of a column in a table.\n",
      "enum": [
        "string",
        "boolean",
        "bytes",
        "date",
        "datetime",
        "dirref",
        "fileref",
        "float",
        "float64",
        "integer",
        "int64",
        "numeric",
        "record",
        "text",
        "time",
        "timestamp"
      ],
      "type": "string"
    },
    "TableModel": {
      "description": "one table in a schema",
      "properties": {
        "columns": {
          "items": {
            "$ref": "#/definitions/ColumnModel"
          },
          "type": "array"
        },
        "datePartitionOptions": {
          "$ref": "#/definitions/DatePartitionOptionsModel"
        },
        "intPartitionOptions": {
          "$ref": "#/definitions/IntPartitionOptionsModel"
        },
        "name": {
          "$ref": "#/definitions/ObjectNameProperty"
        },
        "partitionMode": {
          "default": "none",
          "enum": [
            "none",
            "date",
            "int"
          ],
          "type": "string"
        },
        "primaryKey": {
          "description": "Primary key column names. Any columns listed as a primary key will be marked as required by default.\n",
          "items": {
            "$ref": "#/definitions/ColumnNameProperty"
          },
          "type": "array"
        },
        "rowCount": {
          "type": "integer"
        }
      },
      "required": [
        "columns",
        "name"
      ],
      "type": "object"
    },
    "Tag": {
      "description": "A tag associated with a TDR resource (dataset, snapshot)\n",
      "example": "a-resource-tag",
      "type": "string"
    },
    "TagCount": {
      "properties": {
        "count": {
          "description": "Number of occurrences of this tag across accessible same-typed resources",
          "type": "integer"
        },
        "tag": {
          "$ref": "#/definitions/Tag"
        }
      },
      "type": "object"
    },
    "TagCountResultModel": {
      "properties": {
        "tags": {
          "items": {
            "$ref": "#/definitions/TagCount"
          },
          "type": "array"
        },
        "errors": {
          "description": "Errors encountered which may result in a partial tag list returned.",
          "items": {
            "$ref": "#/definitions/ErrorModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "TagUpdateRequestModel": {
      "properties": {
        "add": {
          "description": "Tags to add to the resource.  User-inputted tags will be stripped of leading and trailing whitespace, filtered of empty elements, and deduplicated.  Adding tags already present on the resource will have no effect.\n",
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "required": false,
          "type": "array"
        },
        "remove": {
          "description": "Tags to remove from the resource.  User-inputted tags will be stripped of leading and trailing whitespace, filtered of empty elements, and deduplicated.  Removing tags not present on the resource will have no effect.\n",
          "items": {
            "$ref": "#/definitions/Tag"
          },
          "required": false,
          "type": "array"
        }
      },
      "type": "object"
    },
    "TransactionCloseModel": {
      "properties": {
        "mode": {
          "enum": [
            "commit",
            "rollback"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "TransactionCreateModel": {
      "properties": {
        "description": {
          "description": "optional description to give your transaction",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TransactionModel": {
      "properties": {
        "created_at": {
          "description": "timestamp of transaction creation in RFC3339",
          "type": "string"
        },
        "created_by": {
          "description": "the creator of the transaction",
          "type": "string"
        },
        "description": {
          "description": "the transaction's description, if one was specified",
          "type": "string"
        },
        "id": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "lock": {
          "description": "the id of the flight that is locking the transaction or empty if the transaction is not locked",
          "type": "string"
        },
        "status": {
          "enum": [
            "active",
            "committed",
            "rolled_back"
          ],
          "type": "string"
        },
        "terminated_at": {
          "description": "timestamp of transaction creation in RFC3339",
          "type": "string"
        },
        "terminated_by": {
          "description": "the creator of the transaction",
          "type": "string"
        }
      },
      "required": [
        "id",
        "created_at",
        "created_by"
      ],
      "type": "object"
    },
    "UniqueIdProperty": {
      "description": "Unique identifier for a dataset, snapshot, etc.\n",
      "format": "uuid",
      "type": "string"
    },
    "UnlockResourceRequest": {
      "properties": {
        "forceUnlock": {
          "default": false,
          "description": "If false, the unlock operation will fail if the locking job is still running. If true, the unlock operation will succeed even if the locking job is still running. Use caution with this option, as deleting a lock from a running flight could have unintended consequences.\n",
          "type": "boolean"
        },
        "lockName": {
          "description": "The lock id to remove. The lock name is the locking flight id.\n",
          "type": "string"
        }
      },
      "required": [
        "lockName"
      ],
      "type": "object"
    },
    "UpgradeModel": {
      "properties": {
        "customArgs": {
          "description": "Array of string arguments to the custom upgrade. Only used when upgradeType is custom.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "customName": {
          "description": "Name of custom upgrade to launch. Only used when upgradeType is custom.",
          "type": "string"
        },
        "upgradeName": {
          "description": "Unique name for the upgrade",
          "type": "string"
        },
        "upgradeType": {
          "description": "Enumeration to allow different kinds upgrades",
          "enum": [
            "custom"
          ],
          "type": "string"
        }
      },
      "required": [
        "upgradeName",
        "upgradeType"
      ],
      "type": "object"
    },
    "UpgradeResponseModel": {
      "properties": {
        "endTime": {
          "description": "Timestamp the upgrade completed",
          "type": "string"
        },
        "startTime": {
          "description": "Timestamp the upgrade was started",
          "type": "string"
        },
        "upgradeName": {
          "description": "Unique name for the upgrade",
          "type": "string"
        }
      },
      "type": "object"
    },
    "UserStatusInfo": {
      "description": "",
      "properties": {
        "enabled": {
          "description": "true if the user is enabled in ldap",
          "type": "boolean"
        },
        "userEmail": {
          "description": "user email",
          "type": "string"
        },
        "userSubjectId": {
          "description": "user id",
          "type": "string"
        }
      },
      "required": [
        "enabled",
        "userEmail",
        "userSubjectId"
      ],
      "type": "object"
    },
    "WorkspacePolicyModel": {
      "properties": {
        "workspaceId": {
          "$ref": "#/definitions/UniqueIdProperty"
        },
        "workspaceLink": {
          "type": "string"
        },
        "workspaceName": {
          "type": "string"
        },
        "workspaceNamespace": {
          "type": "string"
        },
        "workspacePolicies": {
          "items": {
            "$ref": "#/definitions/PolicyModel"
          },
          "type": "array"
        }
      },
      "type": "object"
    }
  },
  "securityDefinitions": {
    "oidc": {
      "authorizationUrl": "/oauth2/authorize",
      "flow": "accessCode",
      "scopes": {
        "email": "email authorization",
        "openid": "open id authorization",
        "profile": "profile authorization"
      },
      "tokenUrl": "/oauth2/token",
      "type": "oauth2"
    }
  },
  "security": [
    {
      "oidc": [
        "openid",
        "email",
        "profile"
      ]
    }
  ],
  "x-components": {
    "parameters": {
      "AssetId": {
        "description": "An asset id",
        "in": "path",
        "name": "assetid",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "DatasetPolicyName": {
        "description": "The relevant policy",
        "in": "path",
        "name": "policyName",
        "required": true,
        "schema": {
          "enum": [
            "steward",
            "custodian",
            "snapshot_creator"
          ],
          "type": "string"
        }
      },
      "Depth": {
        "description": "Enumeration depth; -1 means fully expand; 0 means no expansion; 1..N expands that many subdirectories",
        "in": "query",
        "name": "depth",
        "schema": {
          "default": 0,
          "type": "integer"
        }
      },
      "FileId": {
        "description": "A file id",
        "in": "path",
        "name": "fileid",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "Id": {
        "description": "A UUID to used to identify an object in the repository",
        "format": "uuid",
        "in": "path",
        "name": "id",
        "required": true,
        "type": "string"
      },
      "LoadTag": {
        "description": "a load tag",
        "in": "path",
        "name": "loadtag",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "Path": {
        "description": "URL-encoded full path to a file or directory",
        "in": "query",
        "name": "path",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "ProfilePolicyName": {
        "description": "The relevant policy",
        "enum": [
          "owner",
          "user"
        ],
        "in": "path",
        "name": "policyName",
        "required": true,
        "type": "string"
      },
      "SnapshotPolicyName": {
        "description": "The relevant policy",
        "in": "path",
        "name": "policyName",
        "required": true,
        "schema": {
          "enum": [
            "steward",
            "reader",
            "discoverer"
          ],
          "type": "string"
        }
      },
      "TransactionId": {
        "description": "A UUID to used to identify a transaction in a dataset",
        "format": "uuid",
        "in": "path",
        "name": "transactionId",
        "required": true,
        "type": "string"
      }
    }
  }
}
